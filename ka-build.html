<!DOCTYPE html><html>
<!--
[TCO25] BladeRun
Build Date/Time: 07/13/2025 15:22:45

This game has controller support and I recommend using one! It'll (probably) work with any gamepad that your browser can recognize.

I wish I could have more than two levels, but I was losing quite a bit of steam by the end of this, and I do have a life outside of Khan Academy.

PS: Press ` to open the developer console. There's only 4 commands but I still think it's cool.

CODE NOTES:
I wrote this project off of Khan Academy using Typescript, so none of the variables here have type annotations and a few parts of the code (mainly the enums) look pretty.

Some stuff in this project may seem overkill (for example, do I really need a fully homebrew random number generator just for particles?). This is a lot less because I want to show off and a lot more because it's just part of my general "starter kit".

CREDITS:
- Bluebird, for the thumbnail script at the very bottom of this file.
- StackOverflow, for TONS of little snippets scattered throughout the code.

NOTE FOR JUDGES: I wrote this project using TypeScript because I like it much better than normal JS. If you want me to go back to pure JS, please let me know ASAP so I don't write a ton of my second project and then have to translate it.
-->
<head>
    <title>[TCO25] BladeRun</title>
    <!-- Pull down the file for p5.js so we can use it -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.3/lib/p5.js"></script>
    <!-- also grab some fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Red+Hat+Display:wght@500&family=Roboto+Mono&display=swap&family=Tomorrow&display=swap" rel="stylesheet">

<!-- main project code -->
<script type>(()=>{
/* ----- src/constants.ts ----- */
/** If true, skips the NPC logo and goes directly to the main menu when the page loads. */
const SKIP_LOGO = false;
/**
 * All keybinds. `keys` is for keyboard keys and mouse buttons, and `buttons` is for gamepad buttons.
 */
const KEYBINDS = {
    "up": {
        keys: ["w"],
        buttons: ["dpad up"],
    },
    "down": {
        keys: ["s"],
        buttons: ["dpad down"],
    },
    "left": {
        keys: ["a"],
        buttons: ["dpad left"],
    },
    "right": {
        keys: ["d"],
        buttons: ["dpad right"],
    },
    "jump": {
        keys: ["w"],
        buttons: ["a"],
    },
    "wallrun": {
        keys: ["shift"],
        buttons: ["right trigger"],
    },
    "attack": {
        keys: ["left mouse"],
        buttons: ["x"]
    },
    "dash": {
        keys: ["right mouse"],
        buttons: ["b"]
    },
    "menu confirm": {
        keys: ["left mouse", "enter"],
        buttons: ["a"]
    },
    "menu back": {
        keys: ["backspace"],
        buttons: ["b"]
    },
};

/** Shared container for constants. */
const CONSTANTS = {
    GRAVITY: 900,
    PLAYER_GROUND_ACCELERATION: 1800,
    PLAYER_AIR_ACCELERATION: 1800,
    PLAYER_GROUND_FRICTION: 2400,
    PLAYER_AIR_FRICTION: 0,
    // this is a "soft" speed cap - you can't go faster than it just by running, but you get to keep any speed above it that you get from other sources
    PLAYER_MAX_RUN_SPEED: 275,
    PLAYER_MAX_FALL_SPEED: 600,
    // how long you can jump for after falling off a platform or wall, or after exiting a wallrun
    PLAYER_COYOTE_TIME: 0.25,
    PLAYER_JUMP_IMPULSE: -325,
    PLAYER_MAX_WALLRUN_DURATION: 1.5,
    // upward impulse when jumping out of a wallrun
    PLAYER_WALLRUN_JUMP_IMPULSE: -325,
    // gravity multiplier when moving upward
    PLAYER_WALLRUN_UPWARD_GRAVITY_MULTIPLIER: 1,
    // gravity multiplier when moving downward
    PLAYER_WALLRUN_DOWNWARD_GRAVITY_MULTIPLIER: 0.1,
    PLAYER_MAX_WALLRUN_FALL_SPEED: 50,
    // minimum horizontal speed to maintain a wallrun
    PLAYER_MIN_WALLRUN_SPEED: 0,
    PLAYER_WALLRUN_FRICTION: 1200,
    // impulse away from the wall
    PLAYER_WALLJUMP_X_IMPULSE: 350,
    // upward impulse
    PLAYER_WALLJUMP_Y_IMPULSE: -300,
    PLAYER_MAX_WALL_SLIDE_SPEED: 75,
    PLAYER_ATTACK_ARC_START: -Math.PI / 3,
    PLAYER_ATTACK_ARC_END: Math.PI / 3,
    // the attack arc is cut out of an ellipse with this width and height
    PLAYER_ATTACK_ARC_WIDTH: 120,
    PLAYER_ATTACK_ARC_HEIGHT: 60,
    PLAYER_ATTACK_ARC_FORWARD_OFFSET: -5,
    PLAYER_ATTACK_SWING_SPEED: Math.PI * 3,
    // attack cooldown starts after the animation finishes
    PLAYER_ATTACK_COOLDOWN: 0.1,
    // lunge speed is only applied if you're below the max lunge speed or you're lunging in a different direction than you're moving
    PLAYER_ATTACK_LUNGE_SPEED: 450,
    PLAYER_LUNGE_TURNAROUND_ANGLE: Math.PI / 6,
    PLAYER_DASH_SPEED: 750,
    PLAYER_DASH_DURATION: 0.175,
    // by default, how much of your dash velocity is preserved after the dash. this is a multiplier
    // applied to your velocity, not a velocity value
    PLAYER_DASH_PRESERVED_VELOCITY: 0,
    // hitstop after ending a dash
    PLAYER_DASH_END_HITSTOP: 0,
    // whether sliding on a wall recharges your attack lunge
    PLAYER_WALLSLIDE_RECHARGES_LUNGE: true,
    // whether sliding on a wall recharges your dash
    PLAYER_WALLSLIDE_RECHARGES_DASH: false,
    // whether sliding on a wall recharges your wallrun
    PLAYER_WALLSLIDE_RECHARGES_WALLRUN: true,
    // whether entering a wallrun recharges your attack lunge
    PLAYER_WALLRUN_RECHARGES_LUNGE: true,
    // whether entering a wallrun recharges your dash
    PLAYER_WALLRUN_RECHARGES_DASH: false,
    // whether dashing recharges your attack lunge
    PLAYER_DASH_RECHARGES_LUNGE: true,
    // whether dashing recharges your wallrun
    PLAYER_DASH_RECHARGES_WALLRUN: true,
    DEFLECTED_BULLET_SPEED: 900,
    // default hitstop when an enemy is killed
    BASE_ON_KILL_HITSTOP: 0,
    // hitstop when a bullet is deflected
    BULLET_DEFLECT_HITSTOP: 0,
    // how quickly turrets rotate
    TURRET_ENEMY_TRACKING_SPEED: Math.PI * 0.35,
    // how far to either side of its mount a turret can aim
    TURRET_ENEMY_MAX_ANGLE: Math.PI / 2,
    // the turret will fire when it is within this angle of the player
    TURRET_ENEMY_AIM_TOLERANCE: Math.PI * 0.05,
    // delay between turret shots
    TURRET_ENEMY_SHOT_DELAY: 1.25,
    TURRET_ENEMY_BULLET_SPEED: 600,
    BULLET_WALL_MIN_SHOT_DELAY: 0.05,
    BULLET_WALL_MAX_SHOT_DELAY: 0.15,
    BULLET_WALL_SHOT_VELOCITY: 900,
    MELEE_ENEMY_RUN_SPEED: 300,
    MELEE_ENEMY_ACCELERATION: 1800,
    MELEE_ENEMY_DETECTION_RADIUS: 300,
    // which input actions are press-type actions. don't touch this unless you know what you're doing (or do, i'm not your mom)
    PRESS_ACTIONS: ["jump", "attack", "dash", "menu confirm", "menu back"],
};

/** Tags for marking entity attributes. */
var EntityTag;
(function (EntityTag) {
    EntityTag[EntityTag["WALL_COLLISION"] = 0] = "WALL_COLLISION";
    EntityTag[EntityTag["WALLRUN_SURFACE"] = 1] = "WALLRUN_SURFACE";
    EntityTag[EntityTag["IS_ENEMY"] = 2] = "IS_ENEMY";
    EntityTag[EntityTag["BLOCKS_PARTICLES"] = 3] = "BLOCKS_PARTICLES";
    EntityTag[EntityTag["BULLET"] = 4] = "BULLET";
    EntityTag[EntityTag["CHECKPOINT"] = 5] = "CHECKPOINT";
})(EntityTag || (EntityTag = {}));

var GameState;
(function (GameState) {
    GameState[GameState["NPC_LOGO"] = 0] = "NPC_LOGO";
    GameState[GameState["MAIN_MENU"] = 1] = "MAIN_MENU";
    GameState[GameState["GAMEPLAY"] = 2] = "GAMEPLAY";
    GameState[GameState["LEVEL_SELECT"] = 3] = "LEVEL_SELECT";
    GameState[GameState["LEVEL_COMPLETE"] = 4] = "LEVEL_COMPLETE";
})(GameState || (GameState = {}));

// names of all gamepad icons
var GpIcon;
(function (GpIcon) {
    GpIcon[GpIcon["A"] = 0] = "A";
    GpIcon[GpIcon["A_COLORLESS"] = 1] = "A_COLORLESS";
    GpIcon[GpIcon["B"] = 2] = "B";
    GpIcon[GpIcon["B_COLORLESS"] = 3] = "B_COLORLESS";
    GpIcon[GpIcon["X"] = 4] = "X";
    GpIcon[GpIcon["X_COLORLESS"] = 5] = "X_COLORLESS";
    GpIcon[GpIcon["Y"] = 6] = "Y";
    GpIcon[GpIcon["Y_COLORLESS"] = 7] = "Y_COLORLESS";
    GpIcon[GpIcon["DPAD_NONE"] = 8] = "DPAD_NONE";
    GpIcon[GpIcon["DPAD_UP"] = 9] = "DPAD_UP";
    GpIcon[GpIcon["DPAD_DOWN"] = 10] = "DPAD_DOWN";
    GpIcon[GpIcon["DPAD_LEFT"] = 11] = "DPAD_LEFT";
    GpIcon[GpIcon["DPAD_RIGHT"] = 12] = "DPAD_RIGHT";
    GpIcon[GpIcon["DPAD_VERTICAL"] = 13] = "DPAD_VERTICAL";
    GpIcon[GpIcon["DPAD_HORIZONTAL"] = 14] = "DPAD_HORIZONTAL";
    GpIcon[GpIcon["DPAD_ALL"] = 15] = "DPAD_ALL";
    GpIcon[GpIcon["LEFT_BUMPER"] = 16] = "LEFT_BUMPER";
    GpIcon[GpIcon["RIGHT_BUMPER"] = 17] = "RIGHT_BUMPER";
    GpIcon[GpIcon["LEFT_TRIGGER"] = 18] = "LEFT_TRIGGER";
    GpIcon[GpIcon["RIGHT_TRIGGER"] = 19] = "RIGHT_TRIGGER";
    GpIcon[GpIcon["LEFT_STICK_CLICK"] = 20] = "LEFT_STICK_CLICK";
    GpIcon[GpIcon["RIGHT_STICK_CLICK"] = 21] = "RIGHT_STICK_CLICK";
    GpIcon[GpIcon["LEFT_STICK_NONE"] = 22] = "LEFT_STICK_NONE";
    GpIcon[GpIcon["LEFT_STICK_UP"] = 23] = "LEFT_STICK_UP";
    GpIcon[GpIcon["LEFT_STICK_DOWN"] = 24] = "LEFT_STICK_DOWN";
    GpIcon[GpIcon["LEFT_STICK_LEFT"] = 25] = "LEFT_STICK_LEFT";
    GpIcon[GpIcon["LEFT_STICK_RIGHT"] = 26] = "LEFT_STICK_RIGHT";
    GpIcon[GpIcon["LEFT_STICK_VERTICAL"] = 27] = "LEFT_STICK_VERTICAL";
    GpIcon[GpIcon["LEFT_STICK_HORIZONTAL"] = 28] = "LEFT_STICK_HORIZONTAL";
    GpIcon[GpIcon["LEFT_STICK_ALL"] = 29] = "LEFT_STICK_ALL";
    GpIcon[GpIcon["RIGHT_STICK_NONE"] = 30] = "RIGHT_STICK_NONE";
    GpIcon[GpIcon["RIGHT_STICK_UP"] = 31] = "RIGHT_STICK_UP";
    GpIcon[GpIcon["RIGHT_STICK_DOWN"] = 32] = "RIGHT_STICK_DOWN";
    GpIcon[GpIcon["RIGHT_STICK_LEFT"] = 33] = "RIGHT_STICK_LEFT";
    GpIcon[GpIcon["RIGHT_STICK_RIGHT"] = 34] = "RIGHT_STICK_RIGHT";
    GpIcon[GpIcon["RIGHT_STICK_VERTICAL"] = 35] = "RIGHT_STICK_VERTICAL";
    GpIcon[GpIcon["RIGHT_STICK_HORIZONTAL"] = 36] = "RIGHT_STICK_HORIZONTAL";
    GpIcon[GpIcon["RIGHT_STICK_ALL"] = 37] = "RIGHT_STICK_ALL";
})(GpIcon || (GpIcon = {}));

/** Shared container for global variables. */
const Globals = {
    p5: null,
    gameState: null,
    player: null,
    playerSpawn: [-1, -1],
    random: null,
    currentLevelIndex: 0 // self-explanatory
};

// predefines to keep typescript happy
let changeGameState;
/* ----- end of file ----- */ 

/* ----- src/levels.ts ----- */
var LevelEntity;
(function (LevelEntity) {
    LevelEntity[LevelEntity["WALL"] = 0] = "WALL";
    LevelEntity[LevelEntity["WALLRUN_SURFACE"] = 1] = "WALLRUN_SURFACE";
    LevelEntity[LevelEntity["TURRET_ENEMY"] = 2] = "TURRET_ENEMY";
    LevelEntity[LevelEntity["STATIC_LASER"] = 3] = "STATIC_LASER";
    LevelEntity[LevelEntity["FLOATING_TEXT"] = 4] = "FLOATING_TEXT";
    LevelEntity[LevelEntity["CHECKPOINT"] = 5] = "CHECKPOINT";
    LevelEntity[LevelEntity["BULLET_WALL"] = 6] = "BULLET_WALL";
    LevelEntity[LevelEntity["MELEE_ENEMY"] = 7] = "MELEE_ENEMY";
    LevelEntity[LevelEntity["LEVEL_EXIT"] = 8] = "LEVEL_EXIT";
    LevelEntity[LevelEntity["SPIKES"] = 9] = "SPIKES";
})(LevelEntity || (LevelEntity = {}));
// scale factor for all positions and sizes in level data. this exists exclusively to make my life easier because i drew all of these levels on graph paper first
const CELL_SIZE = 60;

/**
 * Loadable objects for all levels. The `load_level` command uses indexes in this array.
 */
const LEVELS = [
    // debug level (only accessible via console)
    {
        // defines the viewport, which limits where the camera can see
        viewportBounds: [0, 0, 10, 10],
        // player spawn point
        playerSpawn: [1.75, 9.25],
        // all entities as a list of arrays. the first item in each array is the entity type, and the remaining items are the arguments passed to its constructor
        entities: [
            [LevelEntity.WALL, 0, 0, 0.5, 10],
            [LevelEntity.WALL, 9.5, 0, 0.5, 10],
            [LevelEntity.WALL, 0.5, 0, 9, 0.5],
            [LevelEntity.WALL, 0.5, 9.5, 9, 0.5],
        ],
    },
    // movement tutorial
    {
        viewportBounds: [-14.5, -5, 13, 5],
        playerSpawn: [-9.5, 4.25],
        entities: [
            [LevelEntity.WALL, -2.5, -2.5, 1.5, 0.5],
            [LevelEntity.WALL, -2.5, -2, 0.5, 7],
            [LevelEntity.WALL, -14.5, 4.5, 12, 0.5],
            [LevelEntity.WALL, -14.5, 0.5, 0.5, 4],
            [LevelEntity.WALL, -14.5, 0, 10, 0.5],
            [LevelEntity.WALL, -5, -5, 0.5, 5],
            [LevelEntity.WALL, -4.5, -5, 11, 0.5],
            [LevelEntity.WALL, 6.5, -5, 0.5, 5],
            [LevelEntity.WALL, 7, -0.5, 6, 0.5],
            [LevelEntity.WALL, 12.5, 0, 0.5, 8],
            [LevelEntity.WALL, 4, 4.5, 8.5, 0.5],
            [LevelEntity.WALL, 4, -2.5, 0.5, 7],
            [LevelEntity.WALL, 9, 3.5, 1.5, 1],
            [LevelEntity.WALLRUN_SURFACE, -1.5, -4.5, 6, 2.5],
            [LevelEntity.CHECKPOINT, -1.5, -2.5],
            [LevelEntity.LEVEL_EXIT, 12, 4],
            [LevelEntity.STATIC_LASER, -1, -2.25, 4, -2.25],
            [LevelEntity.SPIKES, 9.25, 3.25, "up"],
            [LevelEntity.SPIKES, 9.75, 3.25, "up"],
            [LevelEntity.SPIKES, 10.25, 3.25, "up"],
            [LevelEntity.SPIKES, 8.75, 4.25, "left"],
            [LevelEntity.SPIKES, 10.75, 4.25, "right"],
            [LevelEntity.SPIKES, 8.75, 3.75, "left"],
            [LevelEntity.SPIKES, 10.75, 3.75, "right"],
            [LevelEntity.FLOATING_TEXT, -9.5, 2.5, [
                    [
                        ["keybind", "#ffb47a", "[WASD]", GpIcon.LEFT_STICK_NONE],
                        ["text", "#000000", "Move"]
                    ],
                    [
                        ["keybind", "#ffb47a", "[Space]", GpIcon.A],
                        ["text", "#000000", "Jump and walljump"]
                    ]
                ]],
            [LevelEntity.FLOATING_TEXT, -1, -3.4, [
                    [
                        ["keybind", "#ffb47a", "[Shift]", GpIcon.RIGHT_TRIGGER],
                        ["text", "#000000", "Wallrun"]
                    ],
                    [
                        ["text", "#000000", "(on gray surfaces)"],
                    ]
                ]],
            [LevelEntity.FLOATING_TEXT, 9.75, 1.75, [
                    [
                        ["keybind", "#ffb47a", "[Right Mouse]", GpIcon.B],
                        ["text", "#000000", "Dash"]
                    ],
                    [
                        ["text", "#000000", "Can be performed in midair"],
                    ]
                ]]
        ],
    },
    // combat tutorial
    {
        viewportBounds: [0, 0, 25, 11],
        playerSpawn: [2, 4.25],
        entities: [
            [LevelEntity.WALL, 0, 0, 25, 0.5],
            [LevelEntity.WALL, 0, 0.5, 0.5, 4],
            [LevelEntity.WALL, 0, 4.5, 16, 0.5],
            [LevelEntity.WALL, 24.5, 0.5, 0.5, 10],
            [LevelEntity.WALL, 13.5, 10, 11, 0.5],
            [LevelEntity.WALL, 13, 8.5, 0.5, 2],
            [LevelEntity.WALL, 13.5, 8.5, 2, 0.5],
            [LevelEntity.WALL, 15.5, 5, 0.5, 4],
            [LevelEntity.WALL, 16, 6, 5, 0.5],
            [LevelEntity.WALL, 21, 5, 0.5, 3],
            [LevelEntity.WALL, 12, 2, 1, 1],
            [LevelEntity.WALL, 10.5, 2.25, 0.5, 0.25],
            [LevelEntity.WALL, 9.5, 2.75, 0.5, 0.25],
            [LevelEntity.WALL, 9.5, 3, 0.25, 0.5],
            [LevelEntity.BULLET_WALL, 7.25, 0.5, 7.25, 4.5],
            [LevelEntity.BULLET_WALL, 6.75, 0.5, 6.75, 4.5],
            [LevelEntity.BULLET_WALL, 12.25, 0.5, 12.25, 2],
            [LevelEntity.BULLET_WALL, 12.75, 0.5, 12.75, 2],
            [LevelEntity.STATIC_LASER, 12.25, 3, 12.25, 4.5],
            [LevelEntity.STATIC_LASER, 12.75, 3, 12.75, 4.5],
            [LevelEntity.MELEE_ENEMY, 18.5, 5.5],
            [LevelEntity.TURRET_ENEMY, 17.5, 6.75, -Math.PI / 2],
            [LevelEntity.TURRET_ENEMY, 19.5, 6.75, -Math.PI / 2],
            [LevelEntity.CHECKPOINT, 15, 4.5],
            [LevelEntity.CHECKPOINT, 23.5, 10],
            [LevelEntity.LEVEL_EXIT, 13.8, 9.5],
            [LevelEntity.FLOATING_TEXT, 3.5, 2.5, [
                    [
                        ["text", "#000000", "While dashing, you are"]
                    ],
                    [
                        ["text", "#000000", "invulnerable to bullets"]
                    ],
                    [
                        ["text", "#000000", "and enemy attacks."]
                    ],
                ]],
            [LevelEntity.FLOATING_TEXT, 17, 2.5, [
                    [
                        ["keybind", "#ffb47a", "[Left Mouse]", GpIcon.X],
                        ["text", "#000000", "Attack"]
                    ],
                ]],
            [LevelEntity.FLOATING_TEXT, 20, 8.5, [
                    [
                        ["keybind", "#ffb47a", "[Left Mouse]", GpIcon.X],
                        ["text", "#000000", "Deflect bullets"]
                    ],
                ]],
        ],
    },
];

// preprocess all levels and apply cell size
for (const level of LEVELS) {
    level.viewportBounds[0] *= CELL_SIZE;
    level.viewportBounds[1] *= CELL_SIZE;
    level.viewportBounds[2] *= CELL_SIZE;
    level.viewportBounds[3] *= CELL_SIZE;
    level.playerSpawn[0] *= CELL_SIZE;
    level.playerSpawn[1] *= CELL_SIZE;
    for (const entity of level.entities) {
        for (let i = 1; i < entity.length; ++i) {
            if (typeof entity[i] === "number") {
                // by pure coincidence (seriously), turret enemies are the only ones that have a number that shouldn't be scaled
                if (entity[0] !== LevelEntity.TURRET_ENEMY || i < entity.length - 1) {
                    entity[i] *= CELL_SIZE;
                }
            }
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/engine/utils.ts ----- */
/**
 * Represents an error caused when an argument is of the correct type but still invalid for some other reason.
 */
class InvalidArgumentError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidArgumentError";
    }
}
;
/** Converts an angle from degrees to radians. */
function degToRad(angle) {
    return angle * Math.PI / 180;
}
/** Converts an angle from radians to degrees. */
function radToDeg(angle) {
    return angle * 180 / Math.PI;
}
/* ----- end of file ----- */ 

/* ----- src/engine/vector.ts ----- */
// I'm aware that p5 has a built-in Vector class, but it has to be created with createVector() and that requires a reference to a p5 sketch, so it's a huge pain to use in instance mode.
/**
 * Enum representing which unit to use for angles, either `DEGREES` or `RADIANS`.
 */
var AngleUnit;
(function (AngleUnit) {
    AngleUnit[AngleUnit["DEGREES"] = 0] = "DEGREES";
    AngleUnit[AngleUnit["RADIANS"] = 1] = "RADIANS";
})(AngleUnit || (AngleUnit = {}));
/**
 * Represents a 2D vector.
 */
class Vector2D {
    constructor(x, y) {
        if (Array.isArray(x)) {
            this.x = x[0];
            this.y = x[1];
        }
        else if (typeof x === "number") {
            this.x = x;
            this.y = y;
        }
        // if x and y aren't defined, make both components 0
        else {
            this.x = 0;
            this.y = 0;
        }
    }

    /**
     * Constructs a vector from an angle (`theta`) and a length (`radius`). `angleMode` is optional and defaults to whatever `Vector2D.angleMode` is currently set to.
     */
    static fromPolar(theta, radius = 1, angleMode) {
        // we can't use normal default parameters here because the default is whatever the value of Vector2D.angleMode is, not some constant
        angleMode = angleMode ?? Vector2D.angleMode;
        // the built-in sine and cosine functions always use radians
        if (angleMode === Vector2D.AngleUnit.DEGREES) {
            theta = degToRad(theta);
        }
        return new Vector2D(Math.cos(theta) * radius, Math.sin(theta) * radius);
    }

    /**
     * Returns a string representation of the vector.
     */
    toString() {
        return `(${this.x}, ${this.y})`;
    }

    /**
     * Returns the vector's x and y components as an array.
     */
    asArray() {
        return [this.x, this.y];
    }

    /**
     * Sets the vector's x and y components. Returns a reference to the vector for chaining.
     */
    set(x, y) {
        if (Array.isArray(x)) {
            this.x = x[0];
            this.y = x[1];
        }
        else if (x instanceof Vector2D) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }
        // return a reference to ourself so that chained methods work
        return this;
    }

    /**
     * Copies the vector.
     */
    copy() {
        return new Vector2D(this.x, this.y);
    }

    /**
     * Adds to the vector's x and y components. Returns a reference to the vector for chaining.
     */
    add(x, y) {
        if (Array.isArray(x)) {
            this.x += x[0];
            this.y += x[1];
        }
        else if (x instanceof Vector2D) {
            this.x += x.x;
            this.y += x.y;
        }
        else {
            this.x += x;
            this.y += y;
        }
        // return a reference to ourself so that chained methods work
        return this;
    }

    /**
     * Subtracts from the vector's x and y components. Returns a reference to the vector for chaining.
     */
    sub(x, y) {
        if (Array.isArray(x)) {
            this.x -= x[0];
            this.y -= x[1];
        }
        else if (x instanceof Vector2D) {
            this.x -= x.x;
            this.y -= x.y;
        }
        else {
            this.x -= x;
            this.y -= y;
        }
        // return a reference to ourself so that chained methods work
        return this;
    }

    /**
     * Multiplies the vector's x and y components by a scalar. Returns a reference to the vector for chaining.
     */
    mult(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }

    /**
     * Divides the vector's x and y components by a scalar. Returns a reference to the vector for chaining.
     */
    div(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }

    /**
     * Returns the magnitude (length) of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }

    /**
     * Returns the magnitude (length) of the vector, squared. This is faster than `mag()` and can be useful when you don't need the exact length.
     */
    magSq() {
        return Math.pow(this.x, 2) + Math.pow(this.y, 2);
    }

    /**
     * Sets the magnitude (length) of the vector. Returns a reference to the vector for chaining.
     */
    setMag(newMag) {
        // do some division to find a scalar, then use mult() to apply it to both components
        return this.mult(newMag / this.mag());
    }

    /**
     * Limits the magnitude (length) of the vector to between a minimum and maximum value. Returns a reference to the vector for chaining.
     */
    limit(minimum, maximum) {
        // handle overloads
        if (maximum === undefined) {
            maximum = minimum;
            minimum = 0;
        }
        // use magSq() to avoid an expensive square root operation
        if (this.magSq() < Math.pow(minimum, 2)) {
            this.setMag(minimum);
        }
        if (this.magSq() > Math.pow(maximum, 2)) {
            this.setMag(maximum);
        }
        return this;
    }

    /**
     * Returns the angle the vector is pointing in. `angleMode` is optional and defaults to whatever `Vector2D.angleMode` is currently set to.
     */
    heading(angleMode) {
        // we can't use normal default parameters here because the default is whatever the value of Vector2D.angleMode is, not some constant
        angleMode = angleMode ?? Vector2D.angleMode;
        let a = Math.atan2(this.y, this.x);
        if (angleMode === Vector2D.AngleUnit.DEGREES) {
            return radToDeg(a);
        }
        else {
            return a;
        }
    }

    /**
     * Sets the angle the vector is pointing in. `angleMode` is optional and defaults to whatever `Vector2D.angleMode` is currently set to. Returns a reference to the vector for chaining.
     */
    setHeading(newHeading, angleMode) {
        // we can't use normal default parameters here because the default is whatever the value of Vector2D.angleMode is, not some constant
        angleMode = angleMode ?? Vector2D.angleMode;
        if (angleMode === Vector2D.AngleUnit.DEGREES) {
            newHeading = degToRad(newHeading);
        }
        // maintain our current length
        let mag = this.mag();
        this.x = Math.cos(newHeading) * mag;
        this.y = Math.sin(newHeading) * mag;
        return this;
    }

    /**
     * Rotates the vector by some angle, relative to its current heading. `angleMode` is optional and defaults to whatever `Vector2D.angleMode` is currently set to. Returns a reference to the vector for chaining.
     */
    rotate(angle, angleMode) {
        this.setHeading(this.heading() + angle, angleMode);
        return this;
    }

    /**
     * Returns the dot product of the vector and another vector, or another set of x and y components.
     */
    dot(x, y) {
        if (Array.isArray(x)) {
            return this.x * x[0] + this.y * x[1];
        }
        if (x instanceof Vector2D) {
            return this.x * x.x + this.y * x.y;
        }
        return this.x * x + this.y * y;
    }


    /**
     * Normalizes the vector so that its length is 1. A zero vector remains at length 0. Returns a reference to the vector for chaining.
     */
    normalize() {
        // only normalize nonzero vectors
        if (this.x !== 0 || this.y !== 0) {
            this.setMag(1);
        }
        return this;
    }

    /**
     * Returns the distance between the vector's coordinates and other vector's coordinates,  squared. This is faster than `dist()` and can be useful when you don't need the exact distance.
     */
    distSq(x, y) {
        if (Array.isArray(x)) {
            return Math.pow(this.x - x[0], 2) + Math.pow(this.y - x[1], 2);
        }
        if (x instanceof Vector2D) {
            return Math.pow(this.x - x.x, 2) + Math.pow(this.y - x.y, 2);
        }
        return Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2);
    }

    /**
     * Returns the distance between the vector's coordinates and another vector's coordinates.
     */
    dist(x, y) {
        if (Array.isArray(x)) {
            return Math.sqrt(Math.pow(this.x - x[0], 2) + Math.pow(this.y - x[1], 2));
        }
        if (x instanceof Vector2D) {
            return Math.sqrt(Math.pow(this.x - x.x, 2) + Math.pow(this.y - x.y, 2));
        }
        return Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
    }

    /**
     * Returns whether the vector's x and y components are equal to another vector's x and y components.
     */
    equals(x, y) {
        if (Array.isArray(x)) {
            return this.x === x[0] && this.y === x[1];
        }
        if (x instanceof Vector2D) {
            return this.x === x.x && this.y === x.y;
        }
        return this.x === x && this.y === y;
    }
    /**
     * Snaps the vector's components to zero if its length is below a certain threshold. This can be useful for avoiding issues caused by floating-point imprecision. Returns a reference to the vector for chaining.
     */
    snapZero(threshold) {
        // use magSq() to avoid an expensive square root operation
        if (this.magSq() < Math.pow(threshold, 2)) {
            this.x = 0;
            this.y = 0;
        }
        return this;
    }
    /**
     * Returns whether either of the vector's components are not zero.
     */
    nonZero() {
        return this.x !== 0 || this.y !== 0;
    }
}
// make the enum a class property
Vector2D.AngleUnit = AngleUnit;
/**
 * What units to use for angles in `fromPolar` and `heading`. Both methods have parameters that can override this. The default angle mode is `Vector2D.AngleUnit.RADIANS`.
 */
Vector2D.angleMode = Vector2D.AngleUnit.RADIANS;
/* ----- end of file ----- */ 

/* ----- src/engine/input.ts ----- */
/**
 * A button on the gamepad. Uses Xbox button names.
 */
var GpButton;
(function (GpButton) {
    /** X on Playstation controllers. */
    GpButton[GpButton["A"] = 0] = "A";
    /** Circle on Playstation controllers. */
    GpButton[GpButton["B"] = 1] = "B";
    /** Square on Playstation controllers. */
    GpButton[GpButton["X"] = 2] = "X";
    /** Triangle on Playstation controllers. */
    GpButton[GpButton["Y"] = 3] = "Y";
    /** L1 on Playstation controllers. */
    GpButton[GpButton["LEFT_BUMPER"] = 4] = "LEFT_BUMPER";
    /** R1 on Playstation controllers. */
    GpButton[GpButton["RIGHT_BUMPER"] = 5] = "RIGHT_BUMPER";
    /**
     * L2 on Playstation controllers. Active whenever the trigger is touched at all; use `LEFT_TRIGGER_FULL_PULL` to check if it is held all the way down.
     */
    GpButton[GpButton["LEFT_TRIGGER"] = 6] = "LEFT_TRIGGER";
    /**
     * R2 on Playstation controllers. Active whenever the trigger is touched at all; use `RIGHT_TRIGGER_FULL_PULL` to check if it is held all the way down.
     */
    GpButton[GpButton["RIGHT_TRIGGER"] = 7] = "RIGHT_TRIGGER";
    GpButton[GpButton["SHARE"] = 8] = "SHARE";
    GpButton[GpButton["OPTIONS"] = 9] = "OPTIONS";
    /** L3 on Playstation controllers. */
    GpButton[GpButton["LEFT_STICK_CLICK"] = 10] = "LEFT_STICK_CLICK";
    /** R3 on Playstation controllers */
    GpButton[GpButton["RIGHT_STICK_CLICK"] = 11] = "RIGHT_STICK_CLICK";
    GpButton[GpButton["DPAD_UP"] = 12] = "DPAD_UP";
    GpButton[GpButton["DPAD_DOWN"] = 13] = "DPAD_DOWN";
    GpButton[GpButton["DPAD_LEFT"] = 14] = "DPAD_LEFT";
    GpButton[GpButton["DPAD_RIGHT"] = 15] = "DPAD_RIGHT";
    /** Xbox/Playstation logo button */
    GpButton[GpButton["HOME"] = 16] = "HOME";
    /**
     * L2 on Playstation controllers. Only active when the trigger is all the way down; use `LEFT_TRIGGER` to check if it is touched at all.
     */
    GpButton[GpButton["LEFT_TRIGGER_FULL_PULL"] = 17] = "LEFT_TRIGGER_FULL_PULL";
    /**
     * R2 on Playstation controllers. Only active when the trigger is all the way down; use `LEFT_TRIGGER` to check if it is touched at all.
     */
    GpButton[GpButton["RIGHT_TRIGGER_FULL_PULL"] = 18] = "RIGHT_TRIGGER_FULL_PULL";
})(GpButton || (GpButton = {}));

/**
 * An analog axis on the gamepad.
 */
var GpAxis;
(function (GpAxis) {
    GpAxis[GpAxis["LEFT_STICK_X"] = 0] = "LEFT_STICK_X";
    GpAxis[GpAxis["LEFT_STICK_Y"] = 1] = "LEFT_STICK_Y";
    GpAxis[GpAxis["RIGHT_STICK_X"] = 2] = "RIGHT_STICK_X";
    GpAxis[GpAxis["RIGHT_STICK_Y"] = 3] = "RIGHT_STICK_Y";
    GpAxis[GpAxis["LEFT_TRIGGER"] = 4] = "LEFT_TRIGGER";
    GpAxis[GpAxis["RIGHT_TRIGGER"] = 5] = "RIGHT_TRIGGER";
})(GpAxis || (GpAxis = {}));

/**
 * A thumbstick on the gamepad.
 */
var GpThumbstick;
(function (GpThumbstick) {
    GpThumbstick[GpThumbstick["LEFT"] = 0] = "LEFT";
    GpThumbstick[GpThumbstick["RIGHT"] = 1] = "RIGHT";
})(GpThumbstick || (GpThumbstick = {}));
class GamepadManager {
    /**
     * Manages input for a gamepad.
     * @param [padIndex] Which gamepad to poll input from. Useful for multiplayer games. If this is -1, any connected gamepad will be used.
     */
    constructor(padIndex = -1) {
        /** The JS Gamepad API object. */
        this.gamepad = null;
        /**
         * Inner deadzone for analog sticks - if the raw value is closer to 0 than this, it will be snapped to 0.
         */
        this.innerDeadzone = 0.1;
        /**
         * Outer deadzone for analog sticks - if the raw value is closer to -1 or 1 than this, it will be snapped to -1 or 1 respectively.
         */
        this.outerDeadzone = 0.05;
        /**
         * Which gamepad to poll input from; useful for multiplayer games. If this is -1, any connected gamepad will be used.
         */
        this.padIndex_ = padIndex;

        // add the correct method to poll input from the gamepad
        if (padIndex !== -1) {
            const pollInput = () => {
                this.gamepad = navigator.getGamepads()[this.padIndex_];
                // some browsers store the triggers using the axes, but other ones store them using buttons array and this is the only good way i've found to get around that
                if (this.gamepad !== null && this.triggersAreAxes === undefined) {
                    this.triggersAreAxes = this.gamepad.axes[4] != null;
                    console.log(`[GamepadManager] Triggers are ` +
                        `${this.triggersAreAxes ? "axes" : "buttons"}`);
                }
                // repeat every frame
                window.requestAnimationFrame(pollInput);
            };
            window.requestAnimationFrame(pollInput);
        }
        else {
            const pollInput = () => {
                this.gamepad = navigator.getGamepads().find((g) => g !== null) ?? null;
                if (this.gamepad !== null && this.triggersAreAxes === undefined) {
                    this.triggersAreAxes = this.gamepad.axes[4] != null;
                    console.log(`[GamepadManager] Triggers are ` +
                        `${this.triggersAreAxes ? "axes" : "buttons"}`);
                }
                window.requestAnimationFrame(pollInput);
            };
            window.requestAnimationFrame(pollInput);
        }
    }

    static applyDeadzone(value, inner, outer) {
        if (Math.abs(value) < inner) {
            return 0;
        }
        // storing the outer deadzone as distance from the edge is more intuitive
        outer = 1 - outer;
        if (Math.abs(value) > outer) {
            return (value < 0 ? -1 : 1);
        }
        else {
            const mapped = (1 / (outer - inner)) * (Math.abs(value) - inner);
            return value < 0 ? -mapped : mapped;
        }
    }

    /**
     * Returns whether a button on the gamepad is pressed. If the gamepad is disconnected, this method always returns false.
     */
    buttonPressed(button) {
        if (this.gamepad === null) {
            return false;
        }
        // full pull triggers are special cases - the entry in the button array is true whenever the triggers have been touched at all, so we need to check their axes instead
        if (button === 17 /* LEFT_TRIGGER_FULL_PULL */) {
            return (this.triggersAreAxes ? this.gamepad.axes[4] === 1 :
                this.gamepad.buttons[6].value === 1);
        }
        else if (button === 18 /* RIGHT_TRIGGER_FULL_PULL */) {
            return (this.triggersAreAxes ? this.gamepad.axes[5] === 1 :
                this.gamepad.buttons[7].value === 1);
        }
        // otherwise, the enum is laid out so that each button maps directly to its location in  the button array
        else {
            return this.gamepad.buttons[button].pressed;
        }
    }

    /**
     * Returns the value of an analog axis. Trigger values are between 0 and 1, where 1 is a full pull. Thumbstick axes are between -1 and 1, where -1 is all the way left/up and 1 is all the way right/down. If the gamepad is disconnected, this method always returns 0.
     * @param [rawValue=false] If true, deadzone is not applied to thumbstick values. Has no effect on triggers (because they never have deadzone). Defaults to false.
     */
    axisValue(axis, rawValue = false) {
        if (this.gamepad === null) {
            return 0;
        }
        if (axis === 4 /* LEFT_TRIGGER */) {
            if (this.triggersAreAxes) {
                // TODO: fix bug where trigger values are initially 0.5 until updated map value to between 0 and 1
                return (this.gamepad.axes[4] + 1) / 2;
            }
            else {
                // the button value is already between 0 and 1
                return this.gamepad.buttons[6].value;
            }
        }
        else if (axis === 5 /* RIGHT_TRIGGER */) {
            if (this.triggersAreAxes) {
                // map value to between 0 and 1
                return (this.gamepad.axes[5] + 1) / 2;
            }
            else {
                // the button value is already between 0 and 1
                return this.gamepad.buttons[7].value;
            }
        }
        else {
            // stick axes map directly to their location in the axes array (triggers also do, but we handle them differently so it doesn't matter)
            const value = this.gamepad.axes[axis];
            return rawValue ? value : GamepadManager.applyDeadzone(value, this.innerDeadzone, this.outerDeadzone);
        }
    }

    /**
     * Returns the position of a thumbstick. If the gamepad is disconnected, this method always returns a zero vector.
     * @param [rawValue=false] If true, deadzone is not applied to the position.
     */
    stickPos(stick, rawValue = false) {
        if (stick === 0 /* LEFT */) {
            return new Vector2D(this.axisValue(0 /* LEFT_STICK_X */, rawValue), this.axisValue(1 /* LEFT_STICK_Y */, rawValue));
        }
        else {
            return new Vector2D(this.axisValue(2 /* RIGHT_STICK_X */, rawValue), this.axisValue(3 /* RIGHT_STICK_Y */, rawValue));
        }
    }

    /**
     * Returns a normalized (length 1) vector with the position of a thumbstick. If the gamepad is disconnected, this method always returns a zero vector.
     */
    stickVector(stick) {
        return this.stickPos(stick).normalize();
    }

    /**
     * Which gamepad to poll input from. Useful for multiplayer games. If this is -1, any connected gamepad will be used.
     */
    get padIndex() { return this.padIndex_; }

    /**
     * Whether the manager is connected to a gamepad.
     */
    get connected() { return this.gamepad !== null; }
}

const Input = (() => {
    // lookup table for gamepad button names
    const GAMEPAD_BUTTON_LOOKUP = {
        "a": 0 /* A */,
        "b": 1 /* B */,
        "x": 2 /* X */,
        "y": 3 /* Y */,
        "left bumper": 4 /* LEFT_BUMPER */,
        "right bumper": 5 /* RIGHT_BUMPER */,
        "left trigger": 6 /* LEFT_TRIGGER */,
        "right trigger": 7 /* RIGHT_TRIGGER */,
        "share": 8 /* SHARE */,
        "options": 9 /* OPTIONS */,
        "left stick click": 10 /* LEFT_STICK_CLICK */,
        "right stick click": 11 /* RIGHT_STICK_CLICK */,
        "dpad up": 12 /* DPAD_UP */,
        "dpad down": 13 /* DPAD_DOWN */,
        "dpad left": 14 /* DPAD_LEFT */,
        "dpad right": 15 /* DPAD_RIGHT */,
        "home": 16 /* HOME */,
        "left trigger full pull": 17 /* LEFT_TRIGGER_FULL_PULL */,
        "right trigger full pull": 18 /* RIGHT_TRIGGER_FULL_PULL */
    };
    // lookup table to map some key names to more intuitive ones
    const ALTERNATE_KEY_NAMES = {
        "Space": " ",
        "Backquote": "`",
        "Minus": "-",
        "Equal": "=",
        "BracketLeft": "[",
        "BracketRight": "]",
        "Backslash": "\\",
        "Semicolon": ";",
        "Quote": "'",
        "Comma": ",",
        "Period": ".",
        "Slash": "/",
        "ShiftLeft": "left shift",
        "ShiftRight": "right shift",
        "ControlLeft": "left control",
        "ControlRight": "right control",
        "AltLeft": "left alt",
        "AltRight": "right alt",
        "CapsLock": "caps lock",
        "NumLock": "num lock",
        "ScrollLock": "scroll lock",
        "PageUp": "page up",
        "PageDown": "page down",
        "ArrowUp": "up",
        "ArrowDown": "down",
        "ArrowLeft": "left",
        "ArrowRight": "right",
        "Numpad0": "numpad 0",
        "Numpad1": "numpad 1",
        "Numpad2": "numpad 2",
        "Numpad3": "numpad 3",
        "Numpad4": "numpad 4",
        "Numpad5": "numpad 5",
        "Numpad6": "numpad 6",
        "Numpad7": "numpad 7",
        "Numpad8": "numpad 8",
        "Numpad9": "numpad 9",
        "NumpadAdd": "numpad +",
        "NumpadSubtract": "numpad -",
        "NumpadMultiply": "numpad *",
        "NumpadDivide": "numpad /",
        "NumpadEnter": "numpad enter",
        "NumpadDecimal": "numpad ."
    };

    /**
     * All active actions.
     */
    const actions = {};

    /**
     * The state of every keyboard key and mouse button
     */
    const keyStates = {};

    /** Where the last input came from. */
    let lastInputSource = "keyboard";

    /**
     * Timestamp of the previous update; used for updating buffers.
     */
    let prevTimestamp = 0;

    /**
     * The gamepad to use for polling input.
     */
    let gamepad_ = null;

    /**
     * Disables updates when true.
     */
    let paused_ = false;

    function findLastInputSource() {
        if (gamepad_ !== null && gamepad_.connected) {
            // gamepad input overrides keyboard input
            for (let i = 0; i < 6; ++i) {
                if (gamepad_.axisValue(i) !== 0) {
                    return "gamepad";
                }
            }
            for (let i = 0; i < 17; ++i) {
                if (gamepad_.buttonPressed(i)) {
                    return "gamepad";
                }
            }

            // check for keyboard or mouse input
            if (Object.values(keyStates).includes(true)) {
                return "keyboard";
            }
            // preserve the last input source if there haven't been any new inputs
            return lastInputSource;
        }
        // always use the keyboard if there's no gamepad
        return "keyboard";
    }

    return {
        bufferDuration: 0.03,
        get lastInputSource() { return lastInputSource; },
        get gamepad() { return gamepad_; },
        get paused() { return paused_; },
        set paused(value) { paused_ = value; },

        init(canvas, gamepad = null) {
            const canvas_ = document.getElementById(canvas.id());
            // attach input listeners to the canvas - a bonus of doing it this way is that we don't overwrite any listeners we created somewhere else
            canvas_.addEventListener("keydown", (event) => {
                // special keys have entries in the key table
                if (ALTERNATE_KEY_NAMES[event.code] !== undefined) {
                    keyStates[ALTERNATE_KEY_NAMES[event.code]] = true;
                }
                // the codes for letter keys start with "Key"
                else if (event.code.startsWith("Key")) {
                    keyStates[event.code.slice(3).toLowerCase()] = true;
                }
                // the codes for number keys start with "Digit"
                else if (event.code.startsWith("Digit")) {
                    keyStates[event.code.slice(5).toLowerCase()] = true;
                }
                // the original code is always still used
                keyStates[event.code.toLowerCase()] = true;
                // prevents any browser-specific things from happening
                event.preventDefault();
            });
            canvas_.addEventListener("keyup", (event) => {
                // special keys have entries in the key table
                if (ALTERNATE_KEY_NAMES[event.code] !== undefined) {
                    keyStates[ALTERNATE_KEY_NAMES[event.code]] = false;
                }
                // the codes for letter keys start with "Key"
                else if (event.code.startsWith("Key")) {
                    keyStates[event.code.slice(3).toLowerCase()] = false;
                }
                // the codes for number keys start with "Digit"
                else if (event.code.startsWith("Digit")) {
                    keyStates[event.code.slice(5).toLowerCase()] = false;
                }
                // the original code is always still used
                keyStates[event.code.toLowerCase()] = false;
                event.preventDefault();
            });
            canvas_.addEventListener("mousedown", (event) => {
                if (event.button === 0) {
                    keyStates["left click"] = true;
                    keyStates["left mouse"] = true;
                }
                else if (event.button === 1) {
                    keyStates["middle click"] = true;
                    keyStates["middle mouse"] = true;
                }
                else if (event.button === 2) {
                    keyStates["right click"] = true;
                    keyStates["right mouse"] = true;
                }
            });
            canvas_.addEventListener("mouseup", (event) => {
                if (event.button === 0) {
                    keyStates["left click"] = false;
                    keyStates["left mouse"] = false;
                }
                else if (event.button === 1) {
                    keyStates["middle click"] = false;
                    keyStates["middle mouse"] = false;
                }
                else if (event.button === 2) {
                    keyStates["right click"] = false;
                    keyStates["right mouse"] = false;
                }
            });

            gamepad_ = gamepad;
            // start the counter
            prevTimestamp = window.performance.now();

            // setup a callback to update everything
            const updateCallback = () => {
                // delta time is always updated
                const currentTimestamp = window.performance.now();
                const dt = currentTimestamp - prevTimestamp;
                prevTimestamp = currentTimestamp;

                if (!paused_) {
                    lastInputSource = findLastInputSource();

                    // update all actions
                    for (const action of Object.values(actions)) {
                        // figure out whether the action is pressed
                        let actionPressed = action.keys.some((k) => keyStates[k]);
                        // check gamepad buttons if the gamepad is connected
                        if (!actionPressed && gamepad_ !== null && gamepad_.connected) {
                            actionPressed = action.buttons.some((b) => gamepad_.buttonPressed(b));
                        }
                        action.update(actionPressed, dt);
                    }
                }

                // run every frame
                window.requestAnimationFrame(updateCallback);
            };
            window.requestAnimationFrame(updateCallback);
        },

        addAction({ name, keys = [], buttons = [], type = "hold" }) {
            // make sure the action has something assigned to it
            if (keys.length === 0 && buttons.length === 0) {
                throw new InvalidArgumentError(`The action ${name} has no keys or buttons assigned to it.`);
            }

            // keys have to be handled manually because of shift, alt, and control
            const actionKeys = [];
            for (let k of keys) {
                k = k.toLowerCase();
                if (k === "shift") {
                    actionKeys.push("left shift", "right shift");
                }
                else if (k === "alt") {
                    actionKeys.push("left alt", "right alt");
                }
                else if (k === "control") {
                    actionKeys.push("left control", "right control");
                }
                else {
                    actionKeys.push(k);
                }
            }
            
            const action = {
                active: false,
                keys: actionKeys,
                // convert strings to gamepad buttons
                buttons: buttons.map((b) => typeof b === "string" ? GAMEPAD_BUTTON_LOOKUP[b] : b),
                // we'll set this up a bit later
                update: null,
                wasActive: false,
                bufferDuration: 0
            };

            // set update method based on action type
            if (type === "hold") {
                action.update = (pressed, dt) => {
                    action.active = pressed;
                };
            }
            else {
                action.update = (pressed, dt) => {
                    if (pressed) {
                        if (action.bufferDuration > 0) {
                            action.bufferDuration -= dt;
                            action.active = true;
                        }
                        else if (action.wasActive) {
                            action.active = false;
                        }
                        else {
                            action.active = true;
                            action.wasActive = true;
                            action.bufferDuration = Input.bufferDuration;
                        }
                    }
                    else {
                        action.wasActive = false;
                        action.active = false;
                    }
                };
            }
            actions[name] = action;
        },

        /**
         * Returns whether the named action is active. Throws an `InvalidArgumentError` if the action does not exist.
         */
        isActive(name) {
            if (actions.hasOwnProperty(name)) {
                const active = actions[name].active;
                // clear the buffers for press inputs to prevent them from activating multiple times
                actions[name].bufferDuration = 0;
                return active;
            }
            throw new InvalidArgumentError(`The action "${name}" does not exist.`);
        }
    };
})();
/* ----- end of file ----- */

/* ----- src/engine/rect-collider.ts ----- */
/** A rectangular collider. */
class RectCollider {
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // pseudo-members for centering the bounding box on things
    get centerX() { return this.x + this.width / 2; }
    set centerX(value) { this.x = value - this.width / 2; }
    get centerY() { return this.y + this.height / 2; }
    set centerY(value) { this.y = value - this.height / 2; }

     /** Returns whether the collider contains a point. */
    containsPoint(x, y) {
        // handle overloads
        if (x instanceof Vector2D) {
            y = x.y;
            x = x.x;
        }
        return (x > this.x && x < this.x + this.width &&
            y > this.y && y < this.y + this.height);
    }

    /**
     * Returns whether the collider overlaps with another collider. Can optionally set a translation vector that moves them apart.
     * @param [transVec] A reference to store the "minimum translation vector" in. If the colliders overlap, this will be set to the smallest vector that moves this collider completely out of the other one. If the colliders do not overlap, it will be set to a zero vector.
     */
    isColliding(other, transVec) {
        const intersecting = !(this.x > other.x + other.width ||
            this.x + this.width < other.x ||
            this.y > other.y + other.height ||
            this.y + this.height < other.y
        );

        // skip the rest if we don't need to set a vector
        if (!transVec) {
            return intersecting;
        }

        if (!intersecting) {
            transVec.set(0, 0);
            return false;
        }

        // distance between centers on each axis
        const dx = other.centerX - this.centerX;
        const dy = other.centerY - this.centerY;

        // how much the colliders "penetrate" on each axis
        const mx = (this.width / 2 + other.width / 2) - Math.abs(dx);
        const my = (this.height / 2 + other.height / 2) - Math.abs(dy);

        // move the collider along whatever axis it penetrates less
        if (mx <= my) {
            if (dx < 0) {
                transVec.set(mx, 0);
            }
            else {
                transVec.set(-mx, 0);
            }
        }
        else {
            if (dy < 0) {
                transVec.set(0, my);
            }
            else {
                transVec.set(0, -my);
            }
        }

        return true;
    }

    ccw(p1, p2, p3) {
        return ((p3[1] - p1[1]) * (p2[0] - p1[0]) > (p2[1] - p1[1]) * (p3[0] - p2[0]));
    }

    /**
     * Returns whether two line segments intersect. This has issues if some of the points are colinear, but I have better things to do right now so I'll burn that bridge when I get there.
     */
    lineIntersection(l1, l2) {
        return (this.ccw(l1[0], l2[0], l2[1]) !== this.ccw(l1[1], l2[0], l2[1]) &&
            this.ccw(l1[0], l1[1], l2[0]) !== this.ccw(l1[0], l1[1], l2[1]));
    }

    /**
     * Returns whether a line intersects with the collider or is inside it.
     */
    containsLine(x1, y1, x2, y2) {
        // handle overloads
        if (x1 instanceof Vector2D) {
            x2 = y1.x;
            y2 = y1.y;
            y1 = x1.y;
            x1 = x1.x;
        }
        
        // checking whether either endpoint is inside the collider is fast and rules out a lot of collisions
        if (this.containsPoint(x1, y1) || this.containsPoint(x2, y2)) {
            return true;
        }
        
        // give the line a bounding box and check that to rule out even more cases
        const bboxOverlap = !(this.x > Math.max(x1, x2) ||
            this.x + this.width < Math.min(x1, x2) ||
            this.y > Math.max(y1, y2) ||
            this.y + this.width < Math.min(y1, y2)
        );
        if (!bboxOverlap) { return false; }

        // check whether each edge of the collider intersects with the line
        const edges = [
            [[this.x, this.y], [this.x + this.width, this.y]],
            [[this.x + this.width, this.y], [this.x + this.width, this.y + this.height]],
            [[this.x + this.width, this.y + this.height], [this.x, this.y + this.height]],
            [[this.x, this.y + this.height], [this.x, this.y]]
        ];
        const line = [[x1, y1], [x2, y2]];

        // console.log("checking edges");
        for (const edge of edges) {
            if (this.lineIntersection(line, edge)) {
                return true;
            }
        }
        return false;
    }
    ;
}
/* ----- end of file ----- */ 

/* ----- src/engine/kepler.ts ----- */
/** Internal entity tags. */
var KeplerTag;
(function (KeplerTag) {
    /** Entities with the `USES_RAW_DELTA_TIME` tag ignore the time scale when updating. */
    KeplerTag["USES_RAW_DELTA_TIME"] = "USES_RAW_DELTA_TIME";
    /**
     * Entities with the `USES_SCREEN_SPACE_COORDS` tag ignore the camera position. (0, 0) will always be the top left of the screen when rendering.
     */
    KeplerTag["USES_SCREEN_SPACE_COORDS"] = "USES_SCREEN_SPACE_COORDS";
    /**
     * Entities with the `IGNORE_REMOVE` tag will remain in the engine when `removeAll()`, `removeIf()`, or `removeTagged()` are called without setting any parameters.
     */
    KeplerTag["IGNORE_REMOVE"] = "IGNORE_REMOVE";
    /**
     * Entities with the `IGNORE_HITSTOP` tag will continue to be updated during hitstop.
     */
    KeplerTag["IGNORE_HITSTOP"] = "IGNORE_HITSTOP";
})(KeplerTag || (KeplerTag = {}));

/** Kepler, my mildly questionable in-house game engine. */
const Kepler = (() => {
    // utility functions
    /** Framerate-independent version of `lerp()`; used for updating camera position. */
    function damp(a, b, t, dt) {
        t = 1 - Math.exp(-t * dt);
        // i can't use the p5 lerp function because we're running in instance mode
        return (b - a) * t + a;
    }
    function constrain(n, low, high) {
        return (n < low ? low :
            n > high ? high :
                n);
    }
    
    // internal variables
    /** The p5.js sketch running the engine. */
    let p5;

    let rtXScale = 1;
    let rtYScale = 1;

    /** Main entity list; used for everything except rendering. */
    let entities = [];
    /** Entities grouped into display layers. */
    let displayLayers = {};
    /** All active display layers. */
    let layerIndexes = [];
    
    let cameraPos = new Vector2D();
    let cameraTarget = new Vector2D();
    let renderX = 0;
    let renderY = 0;
    let minCameraX = -Infinity;
    let maxCameraX = Infinity;
    let minCameraY = -Infinity;
    let maxCameraY = Infinity;
    let viewportBounds = [
        -Infinity, -Infinity, Infinity, Infinity
    ];
    let cameraZoom_ = 1;
    
    const Kepler = {
        /**
         * Debug toggle to outline entity colliders.
         */
        showHitboxes: false,
        /**
         * Whether to use the camera. Setting this to true without also setting the camera position or target causes strange behavior. Default: false.
         */
        cameraEnabled: false,
        /**
         * If true, the camera is always locked to the target regardless of the camera tightness. Default: false
         */
        cameraLocked: false,
        /**
         * Determines how quickly the camera glides toward the target (if the camera isn't locked). Must be greater than 0. Default: 5
         */
        cameraTightness: 5,
        /** "Speed of time". Must be greater than 0. Default: 1 */
        timeScale: 1,
        /**
         * Hitstop freezes everything for a (usually brief) duration. Gameplay-wise, small hitstops can help "sell" hard hits, kills, and other such events. During hitstop, entities' `update()` methods are not called at all, unless the entity has the `IGNORE_HITSTOP` tag.
         */
        hitstop: 0,

        // getters and setters to emulate public properties
        /**
         * How zoomed in or out the canvas is. Behaves the same as the scale() function. Default: 1
         */
        get cameraZoom() {
            return cameraZoom_;
        },
        set cameraZoom(value) {
            cameraZoom_ = value;
            minCameraX = viewportBounds[0] + Kepler.renderTarget.width / 2 / cameraZoom_;
            maxCameraX = viewportBounds[2] - Kepler.renderTarget.width / 2 / cameraZoom_;
            minCameraY = viewportBounds[1] + Kepler.renderTarget.height / 2 / cameraZoom_;
            maxCameraY = viewportBounds[3] - Kepler.renderTarget.height / 2 / cameraZoom_;
        },

        // getters for read-only properties
        /** The time between the last two frames in seconds, with the current time scale applied. */
        get deltaTime() {
            // native delta time is in milliseconds
            return p5.deltaTime / 1000 * Kepler.timeScale;
        },
        /** The time between the last two frames in seconds, without the current time scale applied. */
        get deltaTimeRaw() {
            return p5.deltaTime / 1000;
        },
        /** The number of entities being updated. */
        get numEntities() {
            return entities.length;
        },
    };
    /**
     * Initializes everything. This *must* be called before any other Kepler methods are used!
     */
    function init(sketch, renderTarget) {
        p5 = sketch;
        Kepler.renderTarget = renderTarget ?? sketch;
        rtXScale = Kepler.renderTarget.width / p5.width;
        rtYScale = Kepler.renderTarget.height / p5.height;
    }
    // normally i'd just define all the public methods on the Kepler object directly, but if i do that then typescript freaks out if i try to overload things
    Kepler.init = init;

    /** Returns the current position of the camera. */
    function getCameraPos() {
        return cameraPos.copy();
    }
    Kepler.getCameraPos = getCameraPos;

    /**
     * Sets the position of the camera. The camera will immediately be snapped here; use setCameraTarget() to move it smoothly.
     */
    function setCameraPos(x, y) {
        if (typeof x !== "number") {
            y = x.y;
            x = x.x;
        }
        cameraPos.set(constrain(x, minCameraX, maxCameraX), constrain(y, minCameraY, maxCameraY));
        // also set the target to prevent the camera from snapping around
        cameraTarget.set(cameraPos);
    }
    Kepler.setCameraPos = setCameraPos;

    /** Returns the position the camera is moving towards. */
    function getCameraTarget() {
        return cameraTarget.copy();
    }
    Kepler.getCameraTarget = getCameraTarget;

    /**
     * Sets the camera target. The camera will move smoothly toward this position; use setCameraPosition() to immediately move it.
     */
    function setCameraTarget(x, y) {
        if (typeof x !== "number") {
            y = x.y;
            x = x.x;
        }
        cameraTarget.set(constrain(x, minCameraX, maxCameraX), constrain(y, minCameraY, maxCameraY));
    }
    Kepler.setCameraTarget = setCameraTarget;

    /**
     * Returns the viewport (the area the camera can see) in the format `[left, top, right, bottom]`.
     */
    function getViewportBounds() {
        return viewportBounds.slice();
    }
    Kepler.getViewportBounds = getViewportBounds;

    /**
     * Sets the viewport, which determines the area that the camera can see.
     */
    function setViewportBounds(left, top, right, bottom) {
        if (Array.isArray(left)) {
            viewportBounds = left.slice();
        }
        else {
            viewportBounds = [left, top, right, bottom];
        }
        minCameraX = viewportBounds[0] + Kepler.renderTarget.width / 2 / cameraZoom_;
        maxCameraX = viewportBounds[2] - Kepler.renderTarget.width / 2 / cameraZoom_;
        minCameraY = viewportBounds[1] + Kepler.renderTarget.height / 2 / cameraZoom_;
        maxCameraY = viewportBounds[3] - Kepler.renderTarget.height / 2 / cameraZoom_;
    }
    Kepler.setViewportBounds = setViewportBounds;

    /** Returns the area that is currently onscreen. */
    function getViewableArea() {
        return [
            cameraPos.x - Kepler.renderTarget.width / 2,
            cameraPos.y - Kepler.renderTarget.height / 2,
            cameraPos.x + Kepler.renderTarget.width / 2,
            cameraPos.y + Kepler.renderTarget.height / 2
        ];
    }
    Kepler.getViewableArea = getViewableArea;

    /**
     * Adds an entity to the engine, then returns a reference to it (this is more useful than it probably sounds).
     * @param [allowSetup=true] Whether to call the entity's `setup()` method (if it has one).
     */
    function addEntity(entity, allowSetup = true) {
        if (allowSetup) {
            entity.setup(); // may or may not do something
        }
        entities.push(entity);
        if (layerIndexes.includes(entity.displayLayer)) {
            displayLayers[entity.displayLayer].push(entity);
        }
        else {
            displayLayers[entity.displayLayer] = [entity];
            layerIndexes.push(entity.displayLayer);
            // make sure layers actually stay in order
            layerIndexes.sort((a, b) => a - b);
            // console.log(layerIndexes);
        }
        return entity;
    }
    Kepler.addEntity = addEntity;

    /**
     * Updates all entities. Should be called once per frame in `draw()`.
     */
    function update() {
        // during hitstop, decrement the timer and only update enemies that specifically ignore it
        if (Kepler.hitstop > 0) {
            // i don't use deltaTimeRaw here for future-proofing if i ever add something that applies some kind of global time scale
            Kepler.hitstop = Math.max(Kepler.hitstop - p5.deltaTime / 1000, 0);
            entities.forEach((e) => {
                if (!e.markForDelete && e.hasTag(KeplerTag.IGNORE_HITSTOP)) {
                    // delta time is always zero during hitstop
                    e.update(0);
                }
            });
        }
        else {
            entities.forEach((e) => {
                // don't update entities that have already been deleted
                if (!e.markForDelete) {
                    if (e.hasTag(KeplerTag.USES_RAW_DELTA_TIME)) {
                        e.update(Kepler.deltaTimeRaw);
                    }
                    else {
                        e.update(Kepler.deltaTime);
                    }
                }
            });
            // update the camera (if enabled)
            if (Kepler.cameraEnabled && Kepler.hitstop <= 0) {
                cameraPos.x = constrain(cameraPos.x, minCameraX, maxCameraX);
                cameraPos.y = constrain(cameraPos.y, minCameraY, maxCameraY);
                cameraTarget.x = constrain(cameraTarget.x, minCameraX, maxCameraX);
                cameraTarget.y = constrain(cameraTarget.y, minCameraY, maxCameraY);
                if (Kepler.cameraLocked) {
                    cameraPos.set(cameraTarget);
                }
                else {
                    cameraPos.set(damp(cameraPos.x, cameraTarget.x, Kepler.cameraTightness, Kepler.deltaTimeRaw), damp(cameraPos.y, cameraTarget.y, Kepler.cameraTightness, Kepler.deltaTimeRaw));
                }
                // console.log(cameraPos);
                renderX = -Math.floor(cameraPos.x - Kepler.renderTarget.width / 2 / Kepler.cameraZoom);
                renderY = -Math.floor(cameraPos.y - Kepler.renderTarget.height / 2 / Kepler.cameraZoom);
            }
        }
        // always garbage collect
        Kepler.deleteIf((e) => e.markForDelete);
    }
    Kepler.update = update;

    // helper function for rendering hitboxes when enabled
    function renderEntity(entity) {
        Kepler.renderTarget.push();
        entity.render(Kepler.renderTarget);
        if (Kepler.showHitboxes && entity.collider) {
            Kepler.renderTarget.noFill();
            Kepler.renderTarget.stroke("#ff00ff");
            Kepler.renderTarget.strokeWeight(2);
            Kepler.renderTarget.rect(entity.collider.x, entity.collider.y, entity.collider.width, entity.collider.height);
        }
        Kepler.renderTarget.pop();
    }
    /**
     * Draws all entities to the canvas.
     */
    function render() {
        if (Kepler.cameraEnabled) {
            Kepler.renderTarget.push();
            Kepler.renderTarget.scale(Kepler.cameraZoom);
            // console.log(`${renderX}, ${renderY}`);
            Kepler.renderTarget.translate(renderX, renderY);
            layerIndexes.forEach((i) => {
                displayLayers[i].forEach((entity) => {
                    if (entity.hasTag(KeplerTag.USES_SCREEN_SPACE_COORDS)) {
                        Kepler.renderTarget.translate(-renderX, -renderY);
                        Kepler.renderTarget.scale(1 / Kepler.cameraZoom);
                        renderEntity(entity);
                        Kepler.renderTarget.scale(Kepler.cameraZoom);
                        Kepler.renderTarget.translate(renderX, renderY);
                    }
                    else {
                        renderEntity(entity);
                    }
                });
            });
            Kepler.renderTarget.pop();
        }
        else {
            layerIndexes.forEach((i) => {
                displayLayers[i].forEach((entity) => {
                    renderEntity(entity);
                });
            });
        }
    }
    Kepler.render = render;

    /**
     * Removes all entities without the `Kepler.IGNORE_REMOVE_ALL` tag.
     * @param [ignoreTag=false] If true, entities with the `Kepler.IGNORE_REMOVE_ALL` tag are also removed.
     * @param [silent=true] If true, entities' `onDelete()` methods are not called.
     */
    function deleteAll(ignoreTag = false, silent = true) {
        if (ignoreTag) {
            if (!silent) {
                entities.forEach((e) => e.onDelete());
            }
            entities = [];
            displayLayers = {};
            layerIndexes = [];
        }
        else {
            // easier than doing this manually
            Kepler.deleteIf((e) => true, ignoreTag, silent);
        }
    }
    Kepler.deleteAll = deleteAll;

     /**
     * Removes all entities that a predicate function returns true for.
     * @param [silent=false] If true, entities' `onDelete()` methods are not called.
     */
    function deleteIf(predicate, ignoreTag = false, silent = false) {
        let filterFn;
        if (ignoreTag) {
            // filter() removes items that a predicate returns *false* for
            filterFn = (e) => !predicate(e);
        }
        else {
            filterFn = (e) => (!predicate(e) || e.hasTag(KeplerTag.IGNORE_REMOVE));
        }
        if (silent) {
            entities = entities.filter(filterFn);
        }
        else {
            const filtered = [];
            entities.forEach((e) => {
                if (filterFn(e)) {
                    filtered.push(e);
                }
                else {
                    e.onDelete();
                }
            });
            entities = filtered;
        }
        // also remove entities from display layers
        layerIndexes.forEach((i) => {
            displayLayers[i] = displayLayers[i].filter(filterFn);
        });
        // remove empty display layers
        layerIndexes = layerIndexes.filter((i) => displayLayers[i].length > 0);
    }
    Kepler.deleteIf = deleteIf;

    /**
     * Removes all entities with a certain tag.
     * @param [silent=false] If true, entities' `onDelete()` methods are not called.
     */
    function deleteTagged(tag, ignoreTag = false, silent = false) {
        deleteIf((e) => e.hasTag(tag), ignoreTag, silent);
    }
    Kepler.deleteTagged = deleteTagged;

    /**
     * Returns an array containing references to all entities.
     */
    function getAll() {
        // shallow copy the array to prevent issues if something modifies it
        return entities.slice();
    }
    Kepler.getAll = getAll;

    /**
     * Returns an array containing references to all entities that a predicate function returns true for.
     */
    function getIf(predicate) {
        return entities.filter(predicate);
    }
    Kepler.getIf = getIf;

    /**
     * Returns an array containing references to all entities that have a certain tag.
     */
    function getTagged(tag) {
        return entities.filter((e) => e.hasTag(tag));
    }
    Kepler.getTagged = getTagged;

    /**
     * Converts a position in screen space (relative to the top left corner of the canvas) to a position in world space (relative to the camera).
     */
    function screenPosToWorldPos(x, y) {
        if (typeof x !== "number") {
            y = x.y;
            x = x.x;
        }
        return new Vector2D((x * rtXScale) - renderX, (y * rtYScale) - renderY);
    }
    Kepler.screenPosToWorldPos = screenPosToWorldPos;

    /**
     * Converts a position in screen space (relative to the top left corner of the canvas) to a position in world space (relative to the camera).
     */
    function worldPosToScreenPos(x, y) {
        if (typeof x !== "number") {
            y = x.y;
            x = x.x;
        }
        return new Vector2D((x + renderX) / rtXScale, (y + renderY) / rtYScale);
    }
    Kepler.worldPosToScreenPos = worldPosToScreenPos;

    /**
     * Converts a position in world space (relative to the camera) to a position in screen space (relative to the top left corner of the canvas).
     */
    function screenMousePos() {
        return new Vector2D(p5.mouseX, p5.mouseY);
    }
    Kepler.screenMousePos = screenMousePos;

    /**
     * Converts a position in world space (relative to the camera) to a position in screen space (relative to the top left corner of the canvas).
     */
    function worldMousePos() {
        return screenPosToWorldPos(screenMousePos());
    }
    Kepler.worldMousePos = worldMousePos;
    return Kepler;
})();

/**
 * Abstract base class that all game entities should extend.
 */
class KEntityBase {
    constructor() {
        /**
         * Which display layer the entity is on. Entities on a higher display layer will always be drawn on top of entities on a lower display layer, regardless of what order they were added to the engine in. Display layers can be any number, including non-integers and negative numbers.
         */
        this.displayLayer = 0;
        /** All of the entity's tags (if it has any). */
        this.tags = [];
        /** If true, the entity will be removed from the engine at the end of the current update. */
        this.markForDelete = false;
    }

    /** Called when the entity is added to the engine. */
    setup() { }

    /** Called when the entity is removed from the engine. */
    onDelete() { }

    /**
     * Draws the entity to the canvas.
     * @param rt The render target.
     */
    render(rt) { }

    /**
     * Updates the entity.
     * @param dt The time between the last two updates in second, with the current time scale applied (unless the entity has the `KeplerTag.USES_RAW_DELTA_TIME` tag).
     */
    update(dt) { }

    /**
     * Returns whether the entity has a certain tag.
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
}
/* ----- end of file ----- */ 

/* ----- src/engine/dev-console.ts ----- */
const CONSOLE_COLORS = {
    LOG: "#c0c0c0",
    WARN: "#ffb52b",
    ERROR: "#ff4747",
    COMMAND: "#36f2ff"
};
const DevConsole = (() => {
    let textSize = 16;
    let numLines = 12;
    let p5;
    let keyQueue = [];
    let lineLength = -1;
    let lineHeight = -1;
    let charWidth = -1;
    let backgroundHeight;
    // using a char array makes a bunch of things easier
    let currentLine = [];
    let outputHistory = [];
    let commandHistory = [];
    let commandHistoryIndex = 0;
    let cursorPos = 0;
    let showCursor = true;
    let cursorFlashTimer = 0.5;
    let functionNames = [];
    let registeredFunctions = {};
    let open_ = false;

    /**
     * Prints a message in the log color (defaults to white). Also prints to the browser console.
     */
    function log(message) {
        printOutput(CONSOLE_COLORS.LOG, message.toString());
    }

    /**
     * Prints a message in the warning color (defaults to yellow). Also prints to the browser console.
     */
    function warn(message) {
        printOutput(CONSOLE_COLORS.WARN, message.toString());
    }

    /**
     * Prints a message in the error color (defaults to red). Also prints to the browser console.
     */
    function error(message) {
        printOutput(CONSOLE_COLORS.ERROR, message.toString());
    }

    /**
     * Attempts to parse arguments and run a command.
     */
    function runCommand() {
        const command = currentLine.join("");
        commandHistory.push(currentLine.slice());
        commandHistoryIndex = commandHistory.length;
        currentLine = [];
        cursorPos = 0;
        printOutput(CONSOLE_COLORS.COMMAND, command);
        
        // you will never convince me that regex isn't a set of arcane runes we pulled out of a cursed temple in the 1950s
        let rawArgs = command.match(/"[^"]+"|[^\s]+/g)
            .map((e) => e.replace(/"(.+)"/, "$1"));
            
        // the first argument is the name of the function
        let fn;
        if (!functionNames.includes(rawArgs[0])) {
            printOutput(CONSOLE_COLORS.ERROR, `Invalid command "${rawArgs[0]}".`);
            return;
        }
        fn = registeredFunctions[rawArgs[0]];
        
        // try to find a matching call signature
        for (const s of fn.signatures) {
            const args = [];
            let i = 0;
            for (; i < s.length && i < rawArgs.length - 1; ++i) {
                let raw = rawArgs[i + 1];
                let parsed;
                if (s[i] === "int") {
                    parsed = Number.parseInt(raw);
                    if (isNaN(parsed)) {
                        break;
                    }
                }
                else if (s[i] === "float") {
                    parsed = Number.parseFloat(raw);
                    if (isNaN(parsed)) {
                        break;
                    }
                }
                else if (s[i] === "bool") {
                    if (raw === "true" || raw === "t" || raw === "1") {
                        parsed = true;
                    }
                    else if (raw === "false" || raw === "f" || raw === "0") {
                        parsed = false;
                    }
                    else {
                        break;
                    }
                }
                else /* s[i] === "string" */ {
                    parsed = raw;
                }
                args.push(parsed);
            }

            if (i === s.length && i === rawArgs.length - 1) {
                // catch any errors thrown by the command
                try {
                    fn.callback(...args);
                }
                catch (e) {
                    // modify the stack so we can add the name of the command
                    const stack = e.stack.split("\n");
                    for (let i = 0; i < stack.length; ++i) {
                        if (stack[i].slice(0, stack[i].indexOf("@")) === "callback") {
                            const cmd = commandHistory[commandHistory.length - 1];
                            stack.splice(i + 1, 0, `devConsole: "${cmd.join("")}"`);
                            break;
                        }
                    }
                    
                    // update the actual stack and send the error the rest of the way up
                    e.stack = stack.join("\n");
                    throw e;
                }
                return;
            }
        }
        printOutput(CONSOLE_COLORS.ERROR, `Invalid call signature for command "${rawArgs[0]}"  (type "help ${rawArgs[0]}" to see all valid signatures).`);
    }

    /**
     * Handles line wrapping and puts text on the screen.
     */
    function printOutput(color, message) {
        const rawLines = message.split("\n");
        const lines = [];
        for (const line of rawLines) {
            for (let i = 0; i < line.length; i += lineLength) {
                lines.push(line.substring(i, i + lineLength).trimStart());
            }
        }

        for (const line of lines) {
            outputHistory.push({ color: color, message: line });
        }

        // remove offscreen lines
        while (outputHistory.length > numLines) {
            outputHistory.shift();
        }
    }
    
    function init(sketch, canvas) {
        p5 = sketch;

        // figure out width and heights
        p5.push();
        p5.textFont("Roboto Mono", textSize);

        charWidth = p5.textWidth("#");
        lineHeight = p5.textLeading();
        lineLength = Math.floor((p5.width - 12) / charWidth);
        backgroundHeight = lineHeight * (numLines + 1) + 13;

        p5.pop();

        // having empty lines here makes displaying things easier
        for (let i = 0; i < numLines; ++i) {
            outputHistory.push({ color: "#00000000", message: "" });
        }

        // set up keyboard input
        const controlKeys = [
            "Enter", "Backspace", "Delete", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"
        ];
        const c = document.getElementById(canvas.id());
        c.addEventListener("keydown", (e) => {
            if (e.key === "`") {
                open_ = !open_;
                keyQueue = [];
                cursorFlashTimer = 0.5;
                showCursor = true;
            }
            else if (open) {
                if (e.key.length === 1 || controlKeys.includes(e.key)) {
                    keyQueue.push(e.key);
                }
            }
        });

        // hijack console functions to also print to this console
        (() => {
            const consoleLog = console.log;
            console.log = (message) => {
                log(message);
                consoleLog(message);
            };
            const consoleWarn = console.warn;
            console.warn = (message) => {
                warn(message);
                consoleWarn(message);
            };
            const consoleError = console.error;
            console.error = (message) => {
                error(message);
                consoleError(message);
            };
        })();
        
        // add default commands
        registerFunction({
            name: "help",
            description: "Prints help messages...I feel like this should be self-explanatory.",
            signatures: [
                [],
                ["string"]
            ],
            callback: (functionName) => {
                if (functionName == null) {
                    let helpMessage = "Available commands:\n";
                    for (const name of functionNames) {
                        helpMessage += `${name}\n`;
                    }
                    helpMessage += 'Command names are case-sensitive. Type "help <name>" for more information on a command.';
                    console.log(helpMessage);
                }
                else {
                    if (functionNames.includes(functionName)) {
                        console.log(registeredFunctions[functionName].description);
                    }
                    else {
                        console.error(`"${functionName}" is not a command.`);
                    }
                }
            },
        });

        registerFunction({
            name: "clear",
            description: "Clears all console output.",
            signatures: [[]],
            callback: () => {
                outputHistory = [];
                for (let i = 0; i < numLines; ++i) {
                    outputHistory.push({ color: "#000000", message: "" });
                }
            }
        });
    }

    /** Updates the console and renders it if it is active. */
    function update() {
        if (!open_) {
            return;
        }
        
        // native delta time is in milliseconds
        cursorFlashTimer -= p5.deltaTime / 1000;
        if (cursorFlashTimer <= 0) {
            showCursor = !showCursor;
            cursorFlashTimer = 0.5;
        }
        
        // update text
        while (keyQueue.length > 0) {
            const char = keyQueue.shift();
            switch (char) {
                case "Enter":
                    runCommand();
                    break;
                case "Backspace":
                    if (currentLine.length > 0 && cursorPos > 0) {
                        currentLine.splice(cursorPos - 1, 1);
                        --cursorPos;
                    }
                    commandHistoryIndex = commandHistory.length;
                    break;
                case "Delete":
                    if (currentLine.length > 0 && cursorPos < currentLine.length) {
                        currentLine.splice(cursorPos, 1);
                    }
                    commandHistoryIndex = commandHistory.length;
                    break;
                case "ArrowUp":
                    if (commandHistory.length === 0) {
                        break;
                    }
                    --commandHistoryIndex;
                    if (commandHistoryIndex < 0) {
                        commandHistoryIndex = commandHistory.length - 1;
                    }
                    currentLine = commandHistory[commandHistoryIndex].slice();
                    cursorPos = currentLine.length;
                    break;
                case "ArrowDown":
                    if (commandHistory.length === 0) {
                        break;
                    }
                    ++commandHistoryIndex;
                    if (commandHistoryIndex === commandHistory.length) {
                        commandHistoryIndex = 0;
                    }
                    currentLine = commandHistory[commandHistoryIndex].slice();
                    cursorPos = currentLine.length;
                    break;
                case "ArrowLeft":
                    if (cursorPos > 0) {
                        --cursorPos;
                    }
                    break;
                case "ArrowRight":
                    if (cursorPos < currentLine.length) {
                        ++cursorPos;
                    }
                    break;
                default:
                    commandHistoryIndex = commandHistory.length;
                    currentLine.splice(cursorPos, 0, char);
                    ++cursorPos;
                    break;
            }
            showCursor = true;
            cursorFlashTimer = 0.5;
        }

        p5.noStroke();
        p5.fill("#000000c0");
        p5.rect(0, 0, p5.width, backgroundHeight);

        p5.textFont("Roboto Mono", textSize);
        p5.textAlign("left", "top");
        for (let i = 0; i < outputHistory.length; ++i) {
            p5.fill(outputHistory[i].color);
            p5.text(outputHistory[i].message, 6, lineHeight * i + 5);
        }

        p5.stroke("#ffffff");
        p5.strokeWeight(2);
        p5.line(0, lineHeight * numLines + 7, p5.width, lineHeight * numLines + 7);

        const currentLinePos = lineHeight * numLines + 12;
        p5.noStroke();
        p5.fill("#ffffff");
        p5.text(currentLine.join(""), 6, currentLinePos);

        if (showCursor) {
            const cursorX = (charWidth + 0.04) * cursorPos + 8;
            p5.stroke("#ffffff");
            p5.strokeWeight(2);
            p5.line(cursorX, currentLinePos - 1, cursorX, currentLinePos + lineHeight - 2);
        }
    }
    
    /**
     * Adds a function to the console.
     */
    function registerFunction({ name, signatures, callback, description = "" }) {
        // run error checking
        if (functionNames.includes(name)) {
            throw new InvalidArgumentError(`The function "${name}" already exists!`);
        }
        if (signatures.length === 0) {
            throw new InvalidArgumentError(`The function "${name}" has no call signatures!`);
        }

        // add signatures to the help message
        let fulldescription = description;
        if (fulldescription !== "") {
            fulldescription += "\n";
        }
        fulldescription += "\n-- CALL SIGNATURES --";
        for (const s of signatures) {
            fulldescription += `\n${name} ` + s.map((arg) => `<${arg}>`).join(" ");
        }

        functionNames.push(name);
        registeredFunctions[name] = {
            signatures: signatures,
            callback: callback,
            description: fulldescription
        };
    }

    return {
        get open() { return open_; },
        init: init,
        update: update,
        registerFunction: registerFunction
    };
})();
/* ----- end of file ----- */ 

/* ----- src/engine/random.ts ----- */
/**
 * A seedable pseudorandom number generator using the SplitMix32 PRNG algorithm.
 */
class SplitMix32 {
    /**
     * A seedable pseudorandom number generator using the SplitMix32 PRNG algorithm.
     * @param [seed] A string or number to initialize the generator with. The same seed will always produce the same sequence of values. The default seed is random and produces a unique sequence of values.
     */
    // you have no idea how viscerally wrong it feels to use a function in a default parameter
    constructor(seed = Date.now()) {
        this.initialSeed = seed;

        // the actual PRNG always uses a number so strings need to be hashed
        if (typeof seed === "string") {
            // hash functions convert a string into a number such that the same string always produces the same number, but different strings will never produce the same number. this is djb2, which isn't the greatest hash but it's also only 6 lines
            this.currentSeed = 0;
            for (const char of seed) {
                // bitwise operations are faster and (much more importantly) probably make me look smarter. this is equivalent to "this.currentSeed = this.currentSeed * 32 + char"
                this.currentSeed = (this.currentSeed << 5) + this.currentSeed + char.charCodeAt(0);
                this.currentSeed |= 0; // constrain to 32-bit integer
            }
        }
        // numeric seeds can be used directly
        else {
            this.currentSeed = seed;
        }
        // similar seeds can sometimes produce the same first few values, so we get past those here
        for (let i = 0; i < 20; ++i) {
            this.gen();
        }
    }

    /** The number or string seed used to initialize the generator. Read-only. */
    get seed() { return this.initialSeed; }

    /** The core SplitMix32 PRNG. Returns a pseudorandom number between 0 and 1. */
    gen() {
        // note: | and |= are used to make JS use bitwise operations, which are significantly faster than normal mutiplication and addition. they also probably make me look smarter, which is always a plus.
        this.currentSeed |= 0;
        this.currentSeed = this.currentSeed + 0x9e3779b9 | 0;
        let t = this.currentSeed ^ this.currentSeed >>> 16;
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ t >>> 15;
        t = Math.imul(t, 0x735a2d97);
        return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
    }

    /**
     * Returns a random floating-point number.
     */
    float(low, high) {
        // handle overloads
        if (high === undefined) {
            high = (low !== undefined ? low : 1);
            low = 0;
        }
        return low + this.gen() * (high - low);
    }

    /**
     * Returns a random integer number.
     */
    int(low, high) {
        return Math.floor(this.float(low, high));
    }

    /**
     * Returns a random boolean (true or false).
     * @param [bias] An optional value between 0 and 1 that makes one result more likely. Avalue of 0 always returns false and a value of 1 always returns true. Defaults to 0.5, which makes both results equally likely.
     */
    bool(bias = 0.5) {
        // handle edge cases
        if (bias <= 0) {
            return false;
        }
        if (bias >= 1) {
            return true;
        }
        return this.gen() < bias;
    }

    /**
     * Shuffles an array. An empty array is (obviously) unchanged.
     */
    shuffle(array) {
        // normally i don't check for things like this, but using a non-array could potentially result in an infinite loop
        if (!Array.isArray(array)) {
            throw new TypeError("[SplitMix32] Cannot shuffle a non-array.");
        }
        const shuffled = array.slice(); // fisher-yates shuffles in-place
        let currentIndex = array.length;
        while (currentIndex !== 0) {
            // pick a remaining element
            const randomIndex = this.int(currentIndex);
            --currentIndex;
            // swap with the current element
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return shuffled;
    }

    /**
     * Returns a random item in an array, or null if the array is empty.
     */
    choose(array) {
        if (array.length === 0) {
            return null;
        }
        return array[this.int(array.length)];
    }
}
/* ----- end of file ----- */ 

/* ----- src/utils/math.ts ----- */
/**
 * Returns the radius of an ellipse at a specific angle in radians.
 */
function ellipseRadius(width, height, angle) {
    return ((width / 2 * height / 2) / Math.sqrt(Math.pow(width / 2, 2) * Math.pow(Math.sin(angle), 2) +
        Math.pow(height / 2, 2) * Math.pow(Math.cos(angle), 2)));
}

/**
 * Maps a value from one range to another.
 */
function map(value, inputStart, inputEnd, outputStart, outputEnd) {
    const slope = (outputEnd - outputStart) / (inputEnd - inputStart);
    return outputStart + slope * (value - inputStart);
}

/**
 * Version of the modulo (%) operator that correctly handles negative numbers.
 */
function modulo(n, m) {
    return ((n % m) + m) % m;
}

/**
 * Limits a number to within a range.
 */
function clamp(n, low, high) {
    if (n < low) {
        return low;
    }
    if (n > high) {
        return high;
    }
    return n;
}
/* ----- end of file ----- */

/* ----- src/utils/physics.ts ----- */
/**
 * Returns whether a point is inside of a polygon.
 */
function pointInPolygon(point, polygon) {
    const x = point.x, y = point.y;
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) {
            inside = !inside;
        }
    }
    return inside;
}
/* ----- end of file ----- */

/* ----- src/utils/gamepad-icons.ts ----- */
// these are free to use with credit
const GAMEPAD_ICONS = {
    [GpIcon.A]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 80, 80);
            rt.fill(92, 232, 79);
            rt.beginShape();
            rt.vertex(-7.4, 12);
            rt.vertex(-10, 20);
            rt.vertex(-20, 20);
            rt.vertex(-4, -24);
            rt.vertex(4, -24);
            rt.vertex(20, 20);
            rt.vertex(10, 20);
            rt.vertex(7.4, 12);
            rt.endShape("close");
            rt.fill(26, 28, 44);
            rt.beginShape();
            rt.vertex(0, -12);
            rt.vertex(5.6, 4);
            rt.vertex(-5.6, 4);
            rt.endShape("close");
            rt.pop();
        }
    },
    [GpIcon.A_COLORLESS]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 80, 80);
            rt.fill(255);
            rt.beginShape();
            rt.vertex(-7.4, 12);
            rt.vertex(-10, 20);
            rt.vertex(-20, 20);
            rt.vertex(-4, -24);
            rt.vertex(4, -24);
            rt.vertex(20, 20);
            rt.vertex(10, 20);
            rt.vertex(7.4, 12);
            rt.endShape("close");
            rt.fill(26, 28, 44);
            rt.beginShape();
            rt.vertex(0, -12);
            rt.vertex(5.6, 4);
            rt.vertex(-5.6, 4);
            rt.endShape("close");
            rt.pop();
        }
    },
    [GpIcon.B]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 80, 80);
            rt.fill(250, 82, 102);
            rt.rect(-14, -24, 8, 48);
            rt.rect(-14, -24, 20, 8);
            rt.rect(-14, -4, 20, 8);
            rt.rect(-14, 16, 20, 8);
            rt.arc(5, -10, 28, 28, -90, 90);
            rt.arc(5, 10, 28, 28, -90, 90);
            rt.fill(26, 28, 44);
            rt.ellipse(5, -10, 12, 12);
            rt.ellipse(5, 10, 12, 12);
            rt.pop();
        }
    },
    [GpIcon.B_COLORLESS]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 80, 80);
            rt.fill(255);
            rt.rect(-15, -24, 8, 48);
            rt.rect(-15, -24, 20, 8);
            rt.rect(-15, -4, 20, 8);
            rt.rect(-15, 16, 20, 8);
            rt.arc(5, -10, 28, 28, -90, 90);
            rt.arc(5, 10, 28, 28, -90, 90);
            rt.fill(26, 28, 44);
            rt.ellipse(5, -10, 12, 12);
            rt.ellipse(5, 10, 12, 12);
            rt.pop();
        }
    },
    [GpIcon.X]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 2); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 40, 40);
            rt.noStroke();
            rt.fill(65, 166, 246);
            rt.beginShape();
            rt.vertex(-10, -12);
            rt.vertex(-5, -12);
            rt.vertex(0, -4);
            rt.vertex(5, -12);
            rt.vertex(10, -12);
            rt.vertex(3, 0);
            rt.vertex(10, 12);
            rt.vertex(5, 12);
            rt.vertex(0, 4);
            rt.vertex(-5, 12);
            rt.vertex(-10, 12);
            rt.vertex(-3, 0);
            rt.endShape("close");
            rt.pop();
        }
    },
    [GpIcon.X_COLORLESS]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 2); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 40, 40);
            rt.noStroke();
            rt.fill(255);
            rt.beginShape();
            rt.vertex(-10, -12);
            rt.vertex(-5, -12);
            rt.vertex(0, -4);
            rt.vertex(5, -12);
            rt.vertex(10, -12);
            rt.vertex(3, 0);
            rt.vertex(10, 12);
            rt.vertex(5, 12);
            rt.vertex(0, 4);
            rt.vertex(-5, 12);
            rt.vertex(-10, 12);
            rt.vertex(-3, 0);
            rt.endShape("close");
            rt.pop();
        }
    },
    [GpIcon.Y]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 80, 80);
            rt.noStroke();
            rt.fill(255, 205, 117);
            rt.beginShape();
            rt.vertex(-21, -22);
            rt.vertex(-11, -22);
            rt.vertex(0, -5);
            rt.vertex(11, -22);
            rt.vertex(21, -22);
            rt.vertex(4, 5);
            rt.vertex(4, 26);
            rt.vertex(-4, 26);
            rt.vertex(-4, 5);
            rt.endShape("close");
            rt.pop();
        }
    },
    [GpIcon.Y_COLORLESS]: {
        width: 80,
        height: 80,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 80, 80);
            rt.noStroke();
            rt.fill(255);
            rt.beginShape();
            rt.vertex(-21, -22);
            rt.vertex(-11, -22);
            rt.vertex(0, -5);
            rt.vertex(11, -22);
            rt.vertex(21, -22);
            rt.vertex(4, 5);
            rt.vertex(4, 26);
            rt.vertex(-4, 26);
            rt.vertex(-4, 5);
            rt.endShape("close");
            rt.pop();
        }
    },
    [GpIcon.DPAD_NONE]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noFill();
            rt.stroke(26, 28, 44);
            rt.strokeWeight(4);
            rt.arc(8, 46, 24, 24, 0, 90);
            rt.arc(-8, 46, 24, 24, 90, 180);
            rt.arc(-8, -46, 24, 24, 180, 270);
            rt.arc(8, -46, 24, 24, 270, 360);
            rt.arc(46, 8, 24, 24, 0, 90);
            rt.arc(-46, 8, 24, 24, 90, 180);
            rt.arc(-46, -8, 24, 24, 180, 270);
            rt.arc(46, -8, 24, 24, 270, 360);
            rt.line(-8, -58, 8, -58);
            rt.line(-8, 58, 8, 58);
            rt.line(-58, -8, -58, 8);
            rt.line(58, -8, 58, 8);
            rt.line(-20, -46, -20, -20);
            rt.line(20, -46, 20, -20);
            rt.line(-20, 46, -20, 20);
            rt.line(20, 46, 20, 20);
            rt.line(-46, -20, -20, -20);
            rt.line(46, -20, 20, -20);
            rt.line(-46, 20, -20, 20);
            rt.line(46, 20, 20, 20);
            rt.pop();
        }
    },
    [GpIcon.DPAD_UP]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            // if you call rt.rect() with 8 parameters, the last 4 specify the radius of each corner individually
            rt.rect(-22, -60, 44, 42, 15, 15, 0, 0);
            rt.stroke(26, 28, 44);
            rt.strokeWeight(4);
            rt.noFill();
            rt.arc(8, 46, 24, 24, 0, 90);
            rt.arc(-8, 46, 24, 24, 90, 180);
            rt.arc(46, 8, 24, 24, 0, 90);
            rt.arc(-46, 8, 24, 24, 90, 180);
            rt.arc(-46, -8, 24, 24, 180, 270);
            rt.arc(46, -8, 24, 24, 270, 360);
            rt.line(-8, 58, 8, 58);
            rt.line(-58, -8, -58, 8);
            rt.line(58, -8, 58, 8);
            rt.line(-20, 46, -20, 20);
            rt.line(20, 46, 20, 20);
            rt.line(-46, -20, -20, -20);
            rt.line(46, -20, 20, -20);
            rt.line(-46, 20, -20, 20);
            rt.line(46, 20, 20, 20);
            rt.pop();
        }
    },
    [GpIcon.DPAD_DOWN]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-22, 18, 44, 42, 0, 0, 15, 15);
            rt.stroke(26, 28, 44);
            rt.strokeWeight(6);
            rt.noFill();
            rt.arc(-8, -46, 24, 24, 180, 270);
            rt.arc(8, -46, 24, 24, 270, 360);
            rt.arc(46, 8, 24, 24, 0, 90);
            rt.arc(-46, 8, 24, 24, 90, 180);
            rt.arc(-46, -8, 24, 24, 180, 270);
            rt.arc(46, -8, 24, 24, 270, 360);
            rt.line(-8, -58, 8, -58);
            rt.line(-58, -8, -58, 8);
            rt.line(58, -8, 58, 8);
            rt.line(-20, -46, -20, -20);
            rt.line(20, -46, 20, -20);
            rt.line(-46, -20, -20, -20);
            rt.line(46, -20, 20, -20);
            rt.line(-46, 20, -20, 20);
            rt.line(46, 20, 20, 20);
            rt.pop();
        },
    },
    [GpIcon.DPAD_LEFT]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-60, -22, 42, 44, 15, 0, 0, 15);
            rt.stroke(26, 28, 44);
            rt.strokeWeight(4);
            rt.noFill();
            rt.arc(8, 46, 24, 24, 0, 90);
            rt.arc(-8, 46, 24, 24, 90, 180);
            rt.arc(-8, -46, 24, 24, 180, 270);
            rt.arc(8, -46, 24, 24, 270, 360);
            rt.arc(46, 8, 24, 24, 0, 90);
            rt.arc(46, -8, 24, 24, 270, 360);
            rt.line(-8, -58, 8, -58);
            rt.line(-8, 58, 8, 58);
            rt.line(58, -8, 58, 8);
            rt.line(-20, -46, -20, -20);
            rt.line(20, -46, 20, -20);
            rt.line(-20, 46, -20, 20);
            rt.line(20, 46, 20, 20);
            rt.line(46, -20, 20, -20);
            rt.line(46, 20, 20, 20);
            rt.pop();
        },
    },
    [GpIcon.DPAD_RIGHT]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(18, -22, 42, 44, 0, 15, 15, 0);
            rt.stroke(26, 28, 44);
            rt.strokeWeight(4);
            rt.noFill();
            rt.arc(8, 46, 24, 24, 0, 90);
            rt.arc(-8, 46, 24, 24, 90, 180);
            rt.arc(-8, -46, 24, 24, 180, 270);
            rt.arc(8, -46, 24, 24, 270, 360);
            rt.arc(-46, 8, 24, 24, 90, 180);
            rt.arc(-46, -8, 24, 24, 180, 270);
            rt.line(-8, -58, 8, -58);
            rt.line(-8, 58, 8, 58);
            rt.line(-58, -8, -58, 8);
            rt.line(-20, -46, -20, -20);
            rt.line(20, -46, 20, -20);
            rt.line(-20, 46, -20, 20);
            rt.line(20, 46, 20, 20);
            rt.line(-46, -20, -20, -20);
            rt.line(-46, 20, -20, 20);
            rt.pop();
        }
    },
    [GpIcon.DPAD_VERTICAL]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-22, -60, 44, 42, 15, 15, 0, 0);
            rt.rect(-22, 18, 44, 42, 0, 0, 15, 15);
            rt.stroke(26, 28, 44);
            rt.strokeWeight(4);
            rt.noFill();
            rt.arc(46, 8, 24, 24, 0, 90);
            rt.arc(-46, 8, 24, 24, 90, 180);
            rt.arc(-46, -8, 24, 24, 180, 270);
            rt.arc(46, -8, 24, 24, 270, 360);
            rt.line(-58, -8, -58, 8);
            rt.line(58, -8, 58, 8);
            rt.line(-46, -20, -20, -20);
            rt.line(46, -20, 20, -20);
            rt.line(-46, 20, -20, 20);
            rt.line(46, 20, 20, 20);
            rt.pop();
        }
    },
    [GpIcon.DPAD_HORIZONTAL]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-60, -22, 42, 44, 15, 0, 0, 15);
            rt.rect(18, -22, 42, 44, 0, 15, 15, 0);
            rt.stroke(26, 28, 44);
            rt.strokeWeight(4);
            rt.noFill();
            rt.arc(8, 46, 24, 24, 0, 90);
            rt.arc(-8, 46, 24, 24, 90, 180);
            rt.arc(-8, -46, 24, 24, 180, 270);
            rt.arc(8, -46, 24, 24, 270, 360);
            rt.line(-8, -58, 8, -58);
            rt.line(-8, 58, 8, 58);
            rt.line(-20, -46, -20, -20);
            rt.line(20, -46, 20, -20);
            rt.line(-20, 46, -20, 20);
            rt.line(20, 46, 20, 20);
            rt.pop();
        },
    },
    [GpIcon.DPAD_ALL]: {
        width: 90,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale * 0.75); // easier than redoing the math
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-22, -60, 44, 120, 15);
            rt.rect(-60, -22, 120, 44, 15);
            rt.pop();
        }
    },
    [GpIcon.LEFT_BUMPER]: {
        width: 90,
        height: 60,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y - 2);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(-25, 12, 40, 40);
            rt.ellipse(25, 12, 40, 40);
            rt.ellipse(-35, -18, 20, 20);
            rt.ellipse(35, -11, 20, 20);
            rt.beginShape();
            rt.vertex(35, -21);
            rt.vertex(45, -10);
            rt.vertex(45, 12);
            rt.vertex(25, 32);
            rt.vertex(-25, 32);
            rt.vertex(-45, 15);
            rt.vertex(-45, -19);
            rt.vertex(-35, -28);
            rt.vertex(-2, -28);
            rt.vertex(8, -21);
            rt.endShape("close");
            rt.fill(255);
            rt.rect(-24, -10, 6, 32);
            rt.rect(-24, 16, 22, 6);
            rt.fill(255);
            rt.rect(2, -10, 6, 32);
            rt.rect(2, -10, 14, 6);
            rt.rect(2, 3, 14, 6);
            rt.rect(2, 16, 14, 6);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(6);
            rt.arc(16.5, -0.5, 13, 13, -90, 90);
            rt.arc(16.5, 12.5, 13, 13, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_BUMPER]: {
        width: 90,
        height: 60,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y - 2);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(25, 12, 40, 40);
            rt.ellipse(-25, 12, 40, 40);
            rt.ellipse(35, -18, 20, 20);
            rt.ellipse(-35, -11, 20, 20);
            rt.beginShape();
            rt.vertex(-35, -21);
            rt.vertex(-45, -10);
            rt.vertex(-45, 12);
            rt.vertex(-25, 32);
            rt.vertex(25, 32);
            rt.vertex(45, 15);
            rt.vertex(45, -19);
            rt.vertex(35, -28);
            rt.vertex(2, -28);
            rt.vertex(-8, -21);
            rt.endShape("close");
            rt.noStroke();
            rt.fill(255);
            rt.rect(-26, -10, 6, 32);
            rt.rect(-26, -10, 14, 6);
            rt.rect(-26, 6, 14, 6);
            rt.beginShape();
            rt.vertex(-16, 10);
            rt.vertex(-10, 22);
            rt.vertex(-2, 22);
            rt.vertex(-8, 10);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(6);
            rt.arc(-14, 1, 16, 16, -90, 90);
            rt.noStroke();
            rt.fill(255);
            rt.rect(4, -10, 6, 32);
            rt.rect(4, -10, 13, 6);
            rt.rect(4, 3, 13, 6);
            rt.rect(4, 16, 13, 6);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(6);
            rt.arc(17.5, -0.5, 13, 13, -90, 90);
            rt.arc(17.5, 12.5, 13, 13, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.LEFT_TRIGGER]: {
        width: 90,
        height: 100,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(33, -38, 24, 24);
            rt.ellipse(-33, -38, 24, 24);
            rt.ellipse(33, 38, 24, 24);
            rt.ellipse(0, 20, 60, 60);
            rt.beginShape();
            rt.vertex(45, -38);
            rt.vertex(33, -50);
            rt.vertex(-33, -50);
            rt.vertex(-45, -38);
            rt.vertex(-30, 25);
            rt.vertex(0, 50);
            rt.vertex(33, 50);
            rt.vertex(45, 38);
            rt.endShape("close");
            rt.fill(255);
            rt.rect(-16, -16, 6, 32);
            rt.rect(-16, 10, 22, 6);
            rt.rect(17, -16, 6, 32);
            rt.rect(8, -16, 24, 6);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_TRIGGER]: {
        width: 90,
        height: 100,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(-33, -38, 24, 24);
            rt.ellipse(33, -38, 24, 24);
            rt.ellipse(-33, 38, 24, 24);
            rt.ellipse(0, 20, 60, 60);
            rt.beginShape();
            rt.vertex(-45, -38);
            rt.vertex(-33, -50);
            rt.vertex(33, -50);
            rt.vertex(45, -38);
            rt.vertex(30, 25);
            rt.vertex(0, 50);
            rt.vertex(-33, 50);
            rt.vertex(-45, 38);
            rt.endShape("close");
            rt.noStroke();
            rt.fill(255);
            rt.rect(-32, -16, 6, 32);
            rt.rect(-32, -16, 14, 6);
            rt.rect(-32, 0, 14, 6);
            rt.beginShape();
            rt.vertex(-22, 4);
            rt.vertex(-16, 16);
            rt.vertex(-8, 16);
            rt.vertex(-14, 4);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(6);
            rt.arc(-18, -5, 16, 16, -90, 90);
            rt.noStroke();
            rt.fill(255);
            rt.rect(9, -16, 6, 32);
            rt.rect(0, -16, 24, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_CLICK]: {
        width: 60,
        height: 60,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y - 2);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-15, 18, 30, 12);
            rt.rect(-30, 6, 60, 12, 6);
            rt.fill(255);
            rt.triangle(0, 22, -12, 12, 12, 12);
            rt.fill(26, 28, 44);
            rt.rect(-11, -30, 6, 32);
            rt.rect(-11, -4, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_CLICK]: {
        width: 60,
        height: 60,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y - 2);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-15, 18, 30, 12);
            rt.rect(-30, 6, 60, 12, 6);
            rt.fill(255);
            rt.triangle(0, 22, -12, 12, 12, 12);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.rect(-12, -30, 6, 32);
            rt.rect(-12, -30, 14, 6);
            rt.rect(-12, -14, 14, 6);
            rt.beginShape();
            rt.vertex(-2, -10);
            rt.vertex(4, 2);
            rt.vertex(12, 2);
            rt.vertex(6, -10);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(26, 28, 44);
            rt.strokeWeight(6);
            rt.arc(0, -19, 16, 16, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_NONE]: {
        width: 70,
        height: 70,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_UP]: {
        width: 70,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, -55, 15, -41, -15, -41);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_DOWN]: {
        width: 70,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, 55, 15, 41, -15, 41);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_LEFT]: {
        width: 90,
        height: 70,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(-55, 0, -41, 15, -41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_RIGHT]: {
        width: 90,
        height: 70,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(55, 0, 41, 15, 41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_VERTICAL]: {
        width: 70,
        height: 110,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, -55, 15, -41, -15, -41);
            rt.triangle(0, 55, 15, 41, -15, 41);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_HORIZONTAL]: {
        width: 110,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(-55, 0, -41, 15, -41, -15);
            rt.triangle(55, 0, 41, 15, 41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.LEFT_STICK_ALL]: {
        width: 110,
        height: 110,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, -55, 15, -41, -15, -41);
            rt.triangle(0, 55, 15, 41, -15, 41);
            rt.triangle(-55, 0, -41, 15, -41, -15);
            rt.triangle(55, 0, 41, 15, 41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.noStroke();
            rt.fill(255);
            rt.rect(-10, -16, 6, 32);
            rt.rect(-10, 10, 22, 6);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_NONE]: {
        width: 70,
        height: 70,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_UP]: {
        width: 70,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, -55, 15, -41, -15, -41);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_DOWN]: {
        width: 70,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, 55, 15, 41, -15, 41);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_LEFT]: {
        width: 90,
        height: 70,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(-55, 0, -41, 15, -41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_RIGHT]: {
        width: 90,
        height: 70,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(55, 0, 41, 15, 41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_VERTICAL]: {
        width: 70,
        height: 110,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, -55, 15, -41, -15, -41);
            rt.triangle(0, 55, 15, 41, -15, 41);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_HORIZONTAL]: {
        width: 110,
        height: 90,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(-55, 0, -41, 15, -41, -15);
            rt.triangle(55, 0, 41, 15, 41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    },
    [GpIcon.RIGHT_STICK_ALL]: {
        width: 110,
        height: 110,
        render(rt, x, y, scale = 1) {
            rt.push();
            rt.translate(x, y);
            rt.scale(scale);
            rt.noStroke();
            rt.fill(26, 28, 44);
            rt.ellipse(0, 0, 70, 70);
            rt.triangle(0, -55, 15, -41, -15, -41);
            rt.triangle(0, 55, 15, 41, -15, 41);
            rt.triangle(-55, 0, -41, 15, -41, -15);
            rt.triangle(55, 0, 41, 15, 41, -15);
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(2);
            rt.ellipse(0, 0, 58, 58);
            rt.scale(0.75); // easier than redoing all the math
            rt.noStroke();
            rt.fill(255);
            rt.rect(-18, -24, 8, 48);
            rt.rect(-17, -24, 19, 8);
            rt.rect(-17, 0, 19, 8);
            rt.beginShape();
            rt.vertex(-3, 0);
            rt.vertex(8, 24);
            rt.vertex(18, 24);
            rt.vertex(7, 0);
            rt.endShape("close");
            rt.noFill();
            rt.stroke(255);
            rt.strokeWeight(8);
            rt.arc(2, -8, 24, 24, -90, 90);
            rt.pop();
        }
    }
};
/* ----- end of file ----- */ 

/* ----- src/entities/bullet.ts ----- */
/** A bullet fired by enemies. */
class Bullet extends KEntityBase {
    constructor(position, velocity, firedBy) {
        super();
        this.displayLayer = 10;
        this.tags = [
            EntityTag.BULLET
        ];

        this.canHitEnemies = false;
        this.position = position;
        this.velocity = velocity;
        this.firedBy = firedBy;
    }

    render(rt) {
        const trailEnd = Vector2D.fromPolar(this.velocity.heading(), -15).add(this.position);
        rt.stroke("#fa1e1e");
        rt.strokeWeight(2);
        rt.line(this.position.x, this.position.y, trailEnd.x, trailEnd.y);
        rt.strokeWeight(6);
    }

    update(dt) {
        this.position.add(this.velocity.copy().mult(dt));
        
        // collide with walls
        const walls = Kepler.getTagged(EntityTag.WALL_COLLISION);
        for (const wall of walls) {
            if (wall.collider.containsPoint(this.position)) {
                this.markForDelete = true;
                return;
            }
        }

        // collide with the player or with enemies (if the bullet has been parried)
        if (!this.canHitEnemies) {
            // the hurtbox is a slightly smaller collider that is used for checking hazards
            if (!Globals.player.hasIFrames && Globals.player.hurtbox.containsPoint(this.position)) {
                Globals.player.onDeath();
                this.markForDelete = true;
            }
        }
        else {
            const targets = Kepler.getTagged(EntityTag.IS_ENEMY);
            for (const target of targets) {
                if (target.collider.containsPoint(this.position)) {
                    target.markForDelete = true;
                    target.onDeath();
                    Kepler.hitstop = CONSTANTS.BASE_ON_KILL_HITSTOP;

                    this.markForDelete = true;
                    return;
                }
            }
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/player.ts ----- */
/** The player. */
class Player extends KEntityBase {
    constructor(x, y) {
        super();
        // whether the player has i-frames ("invincibility frames") and can't be killed by bullets or melee enemies. the player (currently) only has i-frames during a dash
        this.hasIFrames = false;
        // "ground", "air", "wallslide", or "wallrun"
        this.groundState = "air";
        this.coyoteTime = 0;
        // "left" or "right"
        this.facingAngle = "right";
        // "ground", "wallslide", or "wallrun" - this is required because of how coyote time works
        this.jumpState = "ground";
        this.wallSide = "right";
        this.wallrunTime = 0;
        this.canWallrun = false;
        this.attacking = false;
        this.attackLungeAngle = 0;
        this.attackSwingAngle = 0;
        this.attackCooldown = 0;
        // lunge force can only be applied once while in the air
        this.canLunge = false;
        // for the sword animation trail
        this.swordTrailPositions = [];
        this.swordTrailLifetime = 0.075;
        this.dashing = false;
        this.canDash = false;
        this.dashTime = 0;
        // base hitbox for bullet deflection
        this.centeredBulletDeflectHitbox = [
            [-12, -20],
            [-5, -30],
            [20, -28],
            [42, -21],
            [56, -11],
            [60, 0],
            [56, 11],
            [42, 21],
            [20, 28],
            [-5, 30],
            [-12, 20],
        ];
        this.bulletDeflectHitbox = [];

        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(); // defaults to a zero vector
        this.collider = new RectCollider(x - 10, y - 15, 20, 30);
        this.hurtbox = new RectCollider(x - 7, y - 12, 14, 24);
    }
    setup() {
        Kepler.setCameraPos(this.position);
    }
    render(rt) {
        rt.push();
        rt.translate(this.position.x, this.position.y);

        // body
        rt.noStroke();
        rt.fill("#2483ff");
        rt.rect(-this.collider.width / 2, -this.collider.height / 2, this.collider.width, this.collider.height);

        // eye
        rt.fill("#000000");
        rt.circle(this.facingAngle === "left" ? -3 : 3, -7, 6);

        if (this.swordTrailPositions.length > 0) {
            // draw sword trail
            rt.strokeWeight(4);
            for (const [start, end, lifetime] of this.swordTrailPositions) {
                rt.stroke(100, 114, 135, map(lifetime, 0, this.swordTrailLifetime, 0, 255));
                rt.line(start.x, start.y, end.x, end.y);
            }
        }
        rt.pop();

        if (Kepler.showHitboxes) {
            rt.noFill();
            rt.stroke("#ff0000");
            rt.strokeWeight(2);
            rt.rect(this.hurtbox.x, this.hurtbox.y, this.hurtbox.width, this.hurtbox.height);

            if (this.bulletDeflectHitbox.length > 0) {
                rt.beginShape();
                for (const v of this.bulletDeflectHitbox) {
                    rt.vertex(v.x, v.y);
                }
                rt.endShape("close");
            }
        }
    }

    update(dt) {
        if (this.attackCooldown > 0) {
            this.attackCooldown -= dt;
        }
        // attack if possible
        else if (!this.dashing && Input.isActive("attack")) {
            this.attacking = true;
            this.attackSwingAngle = CONSTANTS.PLAYER_ATTACK_ARC_START;
            this.swordTrailPositions = [];

            // find lunge direction
            let aimDir = new Vector2D();
            // only lunge if we're in midair and haven't already
            let lungeInput = true;
            if (Input.lastInputSource === "gamepad") {
                aimDir = Input.gamepad.stickVector(0 /* LEFT */);
            }
            else {
                aimDir = Kepler.worldMousePos().sub(this.position);
            }

            // if there's no directional input, use our facing direction and don't lunge
            if (!aimDir.nonZero()) {
                lungeInput = false;
                aimDir.x = (this.facingAngle === "left" ? -1 : 1);
            }

            this.attackLungeAngle = aimDir.heading();
            if (lungeInput && this.canLunge && this.groundState !== "wallrun") {
                let shouldLunge = true;
                // if we're on the ground, only lunge if we're aimed off of it
                if (this.groundState === "ground") {
                    shouldLunge = (this.attackLungeAngle < -CONSTANTS.PLAYER_LUNGE_TURNAROUND_ANGLE ||
                        this.attackLungeAngle > CONSTANTS.PLAYER_LUNGE_TURNAROUND_ANGLE + Math.PI
                    );
                }
                // if we're moving above the lunge speed, check whether to perform a turnaround
                else if (this.velocity.mag() > CONSTANTS.PLAYER_ATTACK_LUNGE_SPEED) {
                    const angleDelta = this.attackLungeAngle - this.velocity.heading();
                    shouldLunge = Math.abs(angleDelta) >= CONSTANTS.PLAYER_LUNGE_TURNAROUND_ANGLE;
                }
                
                // always make sure we won't be lunging straight down
                if (this.attackLungeAngle > Math.PI / 4 && this.attackLungeAngle < Math.PI * 3 / 4) {
                    shouldLunge = false;
                }
                
                if (shouldLunge) {
                    this.velocity.set(Vector2D.fromPolar(this.attackLungeAngle, CONSTANTS.PLAYER_ATTACK_LUNGE_SPEED));
                    this.canLunge = false;
                }
            }

            this.attackHitboxOffset = Vector2D.fromPolar(this.attackLungeAngle, CONSTANTS.PLAYER_ATTACK_ARC_FORWARD_OFFSET);
        }

        // assume we don't have i-frames so i don't have to remember to reset them everywhere this method cancels a dash
        this.hasIFrames = false;
        if (this.dashing) {
            this.hasIFrames = true;
            this.dashTime -= dt;
            if (this.dashTime < 0) {
                this.dashing = false;
                this.velocity.mult(CONSTANTS.PLAYER_DASH_PRESERVED_VELOCITY);
                if (CONSTANTS.PLAYER_DASH_RECHARGES_LUNGE) {
                    this.canLunge = true;
                }
                if (CONSTANTS.PLAYER_DASH_RECHARGES_WALLRUN) {
                    this.canWallrun = true;
                }
                Kepler.hitstop = CONSTANTS.PLAYER_DASH_END_HITSTOP;
            }
        }
        // dash if possible
        else if (!this.attacking && this.canDash && Input.isActive("dash")) {
            // find dash direction
            let aimDir = new Vector2D();
            if (Input.lastInputSource === "gamepad") {
                aimDir = Input.gamepad.stickVector(0 /* LEFT */);
            }
            else {
                aimDir = Kepler.worldMousePos().sub(this.position).normalize();
            }

            // if there's no directional input, cancel the dash
            if (aimDir.nonZero()) {
                this.dashing = true;
                this.velocity.set(aimDir.mult(CONSTANTS.PLAYER_DASH_SPEED));
                this.dashTime = CONSTANTS.PLAYER_DASH_DURATION;
                this.canDash = false;
                this.coyoteTime = 0;

                if (this.groundState === "wallrun") {
                    this.wallrunTime = 0;
                    this.canWallrun = false;
                }
            }
        }

        // normal movement is disabled during the attack swing/lunge and during dashes
        if (this.attacking) {
            // update where the hitbox is
            const prevSwingAngle = this.attackSwingAngle;
            this.attackSwingAngle += CONSTANTS.PLAYER_ATTACK_SWING_SPEED * dt;
            let attackHitboxEnd = Vector2D.fromPolar(this.attackSwingAngle + this.attackLungeAngle, ellipseRadius(CONSTANTS.PLAYER_ATTACK_ARC_WIDTH, CONSTANTS.PLAYER_ATTACK_ARC_HEIGHT, this.attackSwingAngle)).add(this.attackHitboxOffset);

            const midAngle = prevSwingAngle + (this.attackSwingAngle - prevSwingAngle) / 2;
            
            // update animation trail
            const innerEndpoint = Vector2D.fromPolar(this.attackSwingAngle + this.attackLungeAngle, ellipseRadius(50, 43, this.attackSwingAngle)).add(this.attackHitboxOffset);
            this.swordTrailPositions.push([
                innerEndpoint, attackHitboxEnd, this.swordTrailLifetime
            ]);

            // add a second segment halfway between the current and previous ones so that the trail looks at least kind of smooth
            const midPointInner = Vector2D.fromPolar(midAngle + this.attackLungeAngle, ellipseRadius(50, 43, midAngle)).add(this.attackHitboxOffset);
            
            const midPointOuter = Vector2D.fromPolar(midAngle + this.attackLungeAngle, ellipseRadius(CONSTANTS.PLAYER_ATTACK_ARC_WIDTH, CONSTANTS.PLAYER_ATTACK_ARC_HEIGHT, midAngle)).add(this.attackHitboxOffset);

            this.swordTrailPositions.push([
                midPointInner, midPointOuter, this.swordTrailLifetime
            ]);

            // extend the hitbox backward so hitting nearby enemies is easier
            const attackHitboxStart = Vector2D.fromPolar(this.attackSwingAngle + this.attackLungeAngle + Math.PI, 3).add(this.attackHitboxOffset);

            attackHitboxEnd = attackHitboxEnd.copy().add(this.position);
            attackHitboxStart.add(this.position);
            
            // check whether we've it han enemy
            const enemies = Kepler.getTagged(EntityTag.IS_ENEMY);
            for (const enemy of enemies) {
                if (enemy.collider.containsLine(attackHitboxStart, attackHitboxEnd)) {
                    enemy.markForDelete = true;
                    enemy.onDeath();
                    Kepler.hitstop = CONSTANTS.BASE_ON_KILL_HITSTOP;
                    break; // only hit one enemy per frame so the hitstop stacks up
                }
            }

            // update where the blade is - this is so that bullets appear to be deflected as the sword passes them
            this.bulletDeflectHitbox = [];
            for (const vertex of this.centeredBulletDeflectHitbox) {
                this.bulletDeflectHitbox.push(new Vector2D(vertex[0], vertex[1])
                    .rotate(this.attackLungeAngle)
                    .add(this.position));
            }

            const bullets = Kepler.getTagged(EntityTag.BULLET);
            for (const bullet of bullets) {
                // only check bullets that haven't already been deflected
                if (!bullet.canHitEnemies &&
                    pointInPolygon(bullet.position, this.bulletDeflectHitbox)) {

                    // if the shooter exists, send the bullet back at them
                    if (bullet.firedBy !== null && !bullet.firedBy.markForDelete) {
                        const delta = bullet.firedBy.position.copy().sub(bullet.position);
                        bullet.velocity = delta.setMag(CONSTANTS.DEFLECTED_BULLET_SPEED);
                        bullet.canHitEnemies = true;
                    }

                    // otherwise, just destroy the bullet
                    else {
                        bullet.markForDelete = true;
                    }

                    Kepler.hitstop = CONSTANTS.BULLET_DEFLECT_HITSTOP;
                    break;
                }
            }

            // end the attack
            if (this.attackSwingAngle > CONSTANTS.PLAYER_ATTACK_ARC_END) {
                this.attacking = false;
                this.attackCooldown = CONSTANTS.PLAYER_ATTACK_COOLDOWN;
                this.bulletDeflectHitbox = [];
            }
        }
        else if (!this.dashing) {
            // horizontal movement
            let moveDir = 0;
            if (Input.lastInputSource === "gamepad") {
                const stickPos = Input.gamepad.axisValue(0 /* LEFT_STICK_X */);
                if (stickPos <= -0.75) {
                    moveDir = -1;
                }
                else if (stickPos >= 0.75) {
                    moveDir = 1;
                }
            }
            else {
                if (Input.isActive("left")) {
                    --moveDir;
                }
                if (Input.isActive("right")) {
                    ++moveDir;
                }
            }

            if ((moveDir < 0 && this.velocity.x >= -CONSTANTS.PLAYER_MAX_RUN_SPEED) ||
                (moveDir > 0 && this.velocity.x <= CONSTANTS.PLAYER_MAX_RUN_SPEED)) {
                
                let acceleration = (
                    this.groundState === "air" ? CONSTANTS.PLAYER_AIR_ACCELERATION :
                    CONSTANTS.PLAYER_GROUND_ACCELERATION
                );

                // apply speed cap
                if (moveDir < 0) {
                    this.velocity.x = Math.max(this.velocity.x - acceleration * dt, -CONSTANTS.PLAYER_MAX_RUN_SPEED);
                }
                else {
                    this.velocity.x = Math.min(this.velocity.x + acceleration * dt, CONSTANTS.PLAYER_MAX_RUN_SPEED);
                }
            }
            else if (this.velocity.x !== 0) {
                const friction = (
                    this.groundState === "air" ? CONSTANTS.PLAYER_AIR_FRICTION :
                    this.groundState === "wallrun" ? CONSTANTS.PLAYER_WALLRUN_FRICTION :
                        CONSTANTS.PLAYER_GROUND_FRICTION
                );

                // snap to zero to prevent weird oscillations
                if (Math.abs(this.velocity.x) < friction * dt) {
                    this.velocity.x = 0;
                }
                else {
                    if (this.velocity.x < 0) {
                        this.velocity.x += friction * dt;
                    }
                    else {
                        this.velocity.x -= friction * dt;
                    }
                }
            }

            // update facing angle
            if (this.velocity.x < 0) {
                this.facingAngle = "left";
            }
            else if (this.velocity.x > 0) {
                this.facingAngle = "right";
            }

            // update wallrun
            if (this.canWallrun) {
                let onWallrunSurface = false;
                const wallRunSurfaces = Kepler.getTagged(EntityTag.WALLRUN_SURFACE);
                for (const surface of wallRunSurfaces) {
                    // wallrunning requires you to be mostly over the surface
                    if (surface.collider.containsPoint(this.position)) {
                        onWallrunSurface = true;
                        break;
                    }
                }

                if (onWallrunSurface) {
                    if (this.groundState === "wallrun") {
                        if (Math.abs(this.velocity.x) < CONSTANTS.PLAYER_MIN_WALLRUN_SPEED ||
                            this.wallrunTime < 0 || !Input.isActive("wallrun")) {
                            this.groundState = "air";
                            this.wallrunTime = 0;
                            this.canWallrun = false;
                        }
                        else {
                            this.wallrunTime -= dt;
                            this.coyoteTime = CONSTANTS.PLAYER_COYOTE_TIME;
                        }
                    }
                    // initiate a wallrun if possible
                    else if (Input.isActive("start wallrun")) {
                        this.wallrunTime = CONSTANTS.PLAYER_MAX_WALLRUN_DURATION;
                        this.groundState = "wallrun";
                        this.jumpState = "wallrun";
                        this.coyoteTime = CONSTANTS.PLAYER_COYOTE_TIME;
                        if (CONSTANTS.PLAYER_WALLRUN_RECHARGES_LUNGE) {
                            this.canLunge = true;
                        }
                        if (CONSTANTS.PLAYER_WALLRUN_RECHARGES_DASH) {
                            this.canDash = true;
                        }
                    }
                }
                else if (this.groundState === "wallrun") {
                    this.groundState = "air";
                    this.wallrunTime = 0;
                    this.canWallrun = false;
                }
            }
        }

        // update sword trail here so that it fades out after the attack finishes
        if (this.swordTrailPositions.length > 0) {
            for (let i = 0; i < this.swordTrailPositions.length; ++i) {
                this.swordTrailPositions[i][2] -= dt;
            }
            // the front segments will always have the lowest lifetimes
            while (this.swordTrailPositions.length > 0 && this.swordTrailPositions[0][2] <= 0) {
                this.swordTrailPositions.shift();
            }
        }

        // jump or apply gravity
        if (!this.dashing) {
            if (this.coyoteTime > 0 && Input.isActive("jump")) {
                if (this.jumpState === "wallslide") {
                    // jumping is an impulse so delta time doesn't affect it
                    this.velocity.y = CONSTANTS.PLAYER_WALLJUMP_Y_IMPULSE;
                    this.velocity.x = (
                        this.wallSide === "left" ? -CONSTANTS.PLAYER_WALLJUMP_X_IMPULSE :
                        CONSTANTS.PLAYER_WALLJUMP_X_IMPULSE
                    );
                }
                else if (this.jumpState === "wallrun") {
                    this.velocity.y = CONSTANTS.PLAYER_WALLRUN_JUMP_IMPULSE;
                }
                else {
                    this.velocity.y = CONSTANTS.PLAYER_JUMP_IMPULSE;
                }

                this.coyoteTime = 0;
            }
            else {
                let gravity = CONSTANTS.GRAVITY * dt;
                if (this.groundState === "wallrun") {
                    if (this.velocity.y < 0) {
                        gravity *= CONSTANTS.PLAYER_WALLRUN_UPWARD_GRAVITY_MULTIPLIER;
                    }
                    else {
                        gravity *= CONSTANTS.PLAYER_WALLRUN_DOWNWARD_GRAVITY_MULTIPLIER;
                    }
                }
                this.velocity.y += gravity;

                // apply fall speed cap
                if (this.groundState === "wallrun") {
                    this.velocity.y = Math.min(this.velocity.y, CONSTANTS.PLAYER_MAX_WALLRUN_FALL_SPEED);
                }
                else if (this.groundState === "wallslide") {
                    this.velocity.y = Math.min(this.velocity.y, CONSTANTS.PLAYER_MAX_WALL_SLIDE_SPEED);
                }
                else {
                    this.velocity.y = Math.min(this.velocity.y, CONSTANTS.PLAYER_MAX_FALL_SPEED);
                }
            }
        }

        // apply delta time and move
        this.position.add(this.velocity.copy().mult(dt));
        this.collider.centerX = this.position.x;
        this.collider.centerY = this.position.y;
        this.hurtbox.centerX = this.position.x;
        this.hurtbox.centerY = this.position.y;

        // collide with walls
        if (this.groundState !== "wallrun") {
            this.groundState = "air"; // assume we're falling
        }
        const walls = Kepler.getTagged(EntityTag.WALL_COLLISION);
        for (const wall of walls) {
            // trans rights!
            const transVec = new Vector2D();
            // isColliding() sets a translation vector using a reference
            if (this.collider.isColliding(wall.collider, transVec)) {
                // console.log(transVec);
                this.position.add(transVec);
                this.collider.centerX = this.position.x;
                this.collider.centerY = this.position.y;
                this.hurtbox.centerX = this.position.x;
                this.hurtbox.centerY = this.position.y;

                // cancel velocity and reset jumps and all that
                if (transVec.x !== 0) {
                    this.velocity.x = 0;
                    if (this.groundState !== "ground") {
                        this.groundState = "wallslide";
                        this.jumpState = "wallslide";
                        this.wallSide = (transVec.x < 0 ? "left" : "right");
                        this.facingAngle = this.wallSide;
                        this.coyoteTime = CONSTANTS.PLAYER_COYOTE_TIME;
                        if (CONSTANTS.PLAYER_WALLSLIDE_RECHARGES_LUNGE) {
                            this.canLunge = true;
                        }
                        if (CONSTANTS.PLAYER_WALLSLIDE_RECHARGES_WALLRUN) {
                            this.canWallrun = true;
                        }
                        if (CONSTANTS.PLAYER_WALLSLIDE_RECHARGES_DASH) {
                            this.canDash = true;
                        }
                    }
                }
                // a translation vector where both components are nonzero (or both components are zero) *should* be impossible
                else {
                    this.velocity.y = 0;
                    // floor collision
                    if (transVec.y < 0) {
                        this.groundState = "ground";
                        this.jumpState = "ground";
                        this.coyoteTime = CONSTANTS.PLAYER_COYOTE_TIME;
                        this.canLunge = true;
                        this.canWallrun = true;
                        this.canDash = true;
                    }
                }
            }
        }

        // final camera update
        Kepler.setCameraTarget(this.position);

        // update timers
        this.coyoteTime -= dt;
    }

    // called when the player is killed
    onDeath() {
        this.velocity.set(0, 0);
        this.position.set(Globals.playerSpawn);
        // TODO: reset game back to where it was when the player last hit a checkpoint
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/wall.ts ----- */
class Wall extends KEntityBase {
    constructor(x, y, width, height) {
        super(); // does literally nothing but is still required because javascript
        this.displayLayer = -10;
        this.tags = [
            EntityTag.WALL_COLLISION,
            EntityTag.BLOCKS_PARTICLES
        ];
        this.collider = new RectCollider(x, y, width, height);
    }

    render(rt) {
        rt.noStroke();
        rt.fill("#20272f");
        rt.rect(this.collider.x, this.collider.y, this.collider.width, this.collider.height);
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/wallrun-surface.ts ----- */
class WallrunSurface extends KEntityBase {
    constructor(x, y, width, height) {
        super(); // does literally nothing but is still required because javascript
        this.displayLayer = -20;
        this.tags = [
            EntityTag.WALLRUN_SURFACE
        ];
        this.collider = new RectCollider(x, y, width, height);
    }

    render(rt) {
        rt.noStroke();
        rt.fill("#9aa6b4");
        rt.rect(this.collider.x, this.collider.y, this.collider.width, this.collider.height);
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/enemy-base.ts ----- */
/** Base class for enemies that the player can kill. */
class EnemyBase extends KEntityBase {
    constructor() {
        super();
        // add tags here because some enemies have extra tags
        this.tags.push(EntityTag.IS_ENEMY);
    }

    /** Called when the player kills the enemy */
    onDeath() { }
}

/* ----- end of file ----- */ 

/* ----- src/entities/turret-enemy.ts ----- */
/** A wall-mounted turret that fires single bullets at the player. */
class TurretEnemy extends EnemyBase {
    constructor(x, y, mountAngle) {
        super();
        this.position = new Vector2D(x, y);
        this.mountAngle = mountAngle;

        this.turretAngle = mountAngle + Math.PI;
        this.minTurretAngle = this.turretAngle - CONSTANTS.TURRET_ENEMY_MAX_ANGLE;
        this.maxTurretAngle = this.turretAngle + CONSTANTS.TURRET_ENEMY_MAX_ANGLE;

        this.collider = new RectCollider(x - 20, y - 20, 40, 40);
        this.shotTimer = 0;
    }

    render(rt) {
        rt.push();
        rt.translate(this.position.x, this.position.y);

        // mount
        rt.push();
        rt.rotate(this.mountAngle);
        rt.noStroke();
        rt.fill("#20272f");
        rt.quad(0, -12, 20, -25, 20, 25, 0, 12);
        rt.pop();
        
        // turret
        rt.push();
        rt.rotate(this.turretAngle);
        rt.fill("#435070");
        rt.circle(0, 0, 32);
        rt.rect(0, -7, 30, 14);
        
        rt.fill("#f83f2a");
        rt.circle(0, 0, 24);
        rt.rect(0, -3, 30, 6);

        rt.fill("#435070");
        rt.circle(0, 0, 16);
        rt.pop();

        rt.pop();
    }

    update(dt) {
        // get an angle pointing to the player
        const playerAngle = Globals.player.position.copy().sub(this.position).heading();

        let delta = modulo((playerAngle - this.turretAngle) + Math.PI, Math.PI * 2) - Math.PI;

        // snap to the angle if we're close enough
        if (Math.abs(delta) < CONSTANTS.TURRET_ENEMY_TRACKING_SPEED * dt) {
            this.turretAngle = playerAngle;
        }
        else {
            if (delta < 0) {
                this.turretAngle -= CONSTANTS.TURRET_ENEMY_TRACKING_SPEED * dt;
            }
            else {
                this.turretAngle += CONSTANTS.TURRET_ENEMY_TRACKING_SPEED * dt;
            }
        }

        // apply aim limits
        this.turretAngle = clamp(this.turretAngle, this.minTurretAngle, this.maxTurretAngle);

        // update delta and fire if possible
        if (this.shotTimer <= 0) {
            delta = modulo((playerAngle - this.turretAngle) + Math.PI, Math.PI * 2) - Math.PI;
            if (Math.abs(delta) < CONSTANTS.TURRET_ENEMY_AIM_TOLERANCE) {
                this.shotTimer = CONSTANTS.TURRET_ENEMY_SHOT_DELAY;

                const shotAngleVector = Vector2D.fromPolar(this.turretAngle);
                
                Kepler.addEntity(new Bullet(
                    // position
                    this.position.copy().add(shotAngleVector.copy().mult(26)),
                    // velocity
                    shotAngleVector.copy().mult(CONSTANTS.TURRET_ENEMY_BULLET_SPEED), this)
                );
            }
        }
        else {
            this.shotTimer -= dt;
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/death-laser.ts ----- */
/** A stationary deadly laser. */
class StaticLaser extends KEntityBase {
    constructor(x1, y1, x2, y2) {
        super();
        this.start = new Vector2D(x1, y1);
        this.end = new Vector2D(x2, y2);

        const delta = this.end.copy().sub(this.start);
        this.renderAngle = delta.heading() - Math.PI / 2;
        this.renderLength = delta.mag();

        const leftHitboxOffset = Vector2D.fromPolar(this.renderAngle, -5);
        const rightHitboxOffset = Vector2D.fromPolar(this.renderAngle, 5);
        // the laser has two hitboxes to make it slightly wider (i should probably write a real polygon collider but i really don't feel like it right now)
        this.hitbox1 = [
            this.start.copy().add(leftHitboxOffset),
            this.end.copy().add(leftHitboxOffset)
        ];
        this.hitbox2 = [
            this.start.copy().add(rightHitboxOffset),
            this.end.copy().add(rightHitboxOffset)
        ];
    }

    render(rt) {
        rt.push();
        rt.translate(this.start.x, this.start.y);
        rt.rotate(this.renderAngle);
        rt.noStroke();

        // laser core
        rt.fill("#ffc2c2");
        rt.rect(-10, 0, 20, this.renderLength);
        rt.fill("#ff8080");
        rt.rect(-7, 0, 14, this.renderLength);
        rt.fill("#fa1e1e");
        rt.rect(-3, 0, 6, this.renderLength);

        // mounts
        rt.fill("#20272f");
        rt.beginShape();
        rt.vertex(-15, 0);
        rt.vertex(-15, 10);
        rt.vertex(-12, 19);
        rt.vertex(-12, 29);
        rt.vertex(12, 29);
        rt.vertex(12, 19);
        rt.vertex(15, 10);
        rt.vertex(15, 0);
        rt.endShape("close");

        rt.fill("#9bacbf");
        rt.rect(-6, 0, 12, 24);

        rt.translate(0, this.renderLength);
        rt.fill("#20272f");
        rt.beginShape();
        rt.vertex(-15, -0);
        rt.vertex(-15, -10);
        rt.vertex(-12, -19);
        rt.vertex(-12, -29);
        rt.vertex(12, -29);
        rt.vertex(12, -19);
        rt.vertex(15, -10);
        rt.vertex(15, -0);
        rt.endShape("close");

        rt.fill("#9bacbf");
        rt.rect(-6, -24, 12, 24);

        rt.pop();

        if (Kepler.showHitboxes) {
            rt.stroke("#ff00ff");
            rt.strokeWeight(2);
            rt.line(this.hitbox1[0].x, this.hitbox1[0].y, this.hitbox1[1].x, this.hitbox1[1].y);
            rt.line(this.hitbox2[0].x, this.hitbox2[0].y, this.hitbox2[1].x, this.hitbox2[1].y);
        }
    }

    update(dt) {
        const colliding = (
            Globals.player.collider.containsLine(this.hitbox1[0], this.hitbox1[1]) ||
            Globals.player.collider.containsLine(this.hitbox2[0], this.hitbox2[1])
        );
        if (colliding) {
            Globals.player.onDeath();
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/floating-text.ts ----- */
/** Floating, multicolored text that can also display keyboard/controller bindings. */
class FloatingText extends KEntityBase {
    constructor(centerX, centerY, chunks) {
        super();
        this.displayLayer = -5;
        // text is stored as a set of objects that represent either a colored block of text, or the text/controller icon for a keybind
        this.keyboardChunks = [];
        // TODO: figure out a way to do this that doesn't require parsing everything twice
        this.gamepadChunks = [];
        
        this.position = new Vector2D(centerX, centerY);

        // parse chunks to figure out where everything should go
        const rt = Kepler.renderTarget;
        rt.push();
        // for some reason, textWidth() only works with the font p5 is currently using, rather than just taking a font as a parameter
        rt.textFont("Tomorrow", 28);
        rt.textStyle("bold");

        // easier than trying to figure out which chunks to add a space to
        const spacerWidth = rt.textWidth(" ");
        // all rows are 40 pixels tall including margins
        const topLineOffset = -((chunks.length - 1) * 40) / 2;

        // chunks are passed as an array of arrays where each sub-array is its own line of text
        for (const [y, row] of chunks.entries()) {
            // find the total width of everything - i wish there was a way to only iterate over each row once, but if there is then i haven't been able to find it
            const keyboardChunkWidths = [];
            const gamepadChunkWidths = [];

            for (const [i, chunk] of row.entries()) {
                // chunks are arrays with different formats depending on whether the chunk is just text or is a keybind (type is determined by the first array element):
                // text: ["text", <color>, <displayed string>]
                // keybind: ["keybind", <text color>, <displayed text for keyboard>, <gamepad icon>]
                if (chunk[0] === "text") {
                    // if the chunk is text, both the keyboard and gamepad widths are the same
                    keyboardChunkWidths.push({
                        type: "chunk",
                        width: rt.textWidth(chunk[2])
                    });
                    gamepadChunkWidths.push({
                        type: "chunk",
                        width: rt.textWidth(chunk[2])
                    });

                    // add a spacer if the next chunk is also text
                    if (i < row.length - 1 && row[i + 1][0] === "text") {
                        keyboardChunkWidths.push({
                            type: "spacer", width: spacerWidth
                        });
                        gamepadChunkWidths.push({
                            type: "spacer", width: spacerWidth
                        });
                    }
                }
                else {
                    keyboardChunkWidths.push({
                        type: "chunk",
                        width: rt.textWidth(chunk[2])
                    });
                    gamepadChunkWidths.push({
                        type: "chunk",
                        width: GAMEPAD_ICONS[chunk[3]].width
                    });

                    // add a spacer to the keyboard chunks because keybind chunks are really just text chunks there
                    if (i < row.length - 1 && row[i + 1][0] === "text") {
                        keyboardChunkWidths.push({
                            type: "spacer", width: spacerWidth
                        });
                    }
                }
            }

            // chain map() into reduce() to get an array of just the widths and then sum them all
            const totalKeyboardWidth = keyboardChunkWidths.map((c) => c.width)
                .reduce((a, b) => a + b);

            // build chunks and add them to the list
            let currentX = -totalKeyboardWidth / 2;
            let chunkIndex = 0;
            for (const widthBlock of keyboardChunkWidths) {
                if (widthBlock.type === "chunk") {
                    const rawChunk = row[chunkIndex];
                    ++chunkIndex; // advance to the next chunk

                    // text is positioned at the center of each chunk
                    currentX += widthBlock.width / 2;

                    if (rawChunk[0] === "text") {
                        this.keyboardChunks.push({
                            type: "text",
                            x: currentX,
                            y: topLineOffset + y * 40,
                            color: rawChunk[1],
                            text: rawChunk[2]
                        });
                    }
                    else {
                        this.keyboardChunks.push({
                            type: "keybind",
                            x: currentX,
                            y: topLineOffset + y * 40,
                            textColor: rawChunk[1],
                            keyboardText: rawChunk[2],
                            controllerIcon: rawChunk[3]
                        });
                    }

                    currentX += widthBlock.width / 2;
                }
                else {
                    currentX += widthBlock.width;
                }
            }

            // repeat for gamepad chunks
            const totalGamepadWidth = gamepadChunkWidths.map((c) => c.width)
                .reduce((a, b) => a + b);
            
            currentX = -totalGamepadWidth / 2;
            chunkIndex = 0;
            for (const widthBlock of gamepadChunkWidths) {
                if (widthBlock.type === "chunk") {
                    const rawChunk = row[chunkIndex];
                    ++chunkIndex; // advance to the next chunk

                    // icons are positioned at the center of each chunk
                    currentX += widthBlock.width / 2;

                    if (rawChunk[0] === "text") {
                        this.gamepadChunks.push({
                            type: "text",
                            x: currentX,
                            y: topLineOffset + y * 40,
                            color: rawChunk[1],
                            text: rawChunk[2]
                        });
                    }
                    else {
                        this.gamepadChunks.push({
                            type: "keybind",
                            x: currentX,
                            y: topLineOffset + y * 40,
                            textColor: rawChunk[1],
                            keyboardText: rawChunk[2],
                            controllerIcon: rawChunk[3]
                        });
                    }

                    currentX += widthBlock.width / 2;
                }
                else {
                    currentX += widthBlock.width;
                }
            }
        }
        rt.pop();
    }
    render(rt) {
        rt.push();
        rt.translate(this.position.x, this.position.y);

        // render text
        rt.noStroke();
        rt.textFont("Tomorrow", 28);
        rt.textStyle("bold");
        rt.textAlign("center", "center");

        // use the chunk set for the current input source
        const chunks = (Input.lastInputSource === "gamepad" ? this.gamepadChunks : this.keyboardChunks);

        for (const chunk of chunks) {
            // if the chunk is text, just render the text
            if (chunk.type === "text") {
                rt.fill(chunk.color);
                rt.text(chunk.text, chunk.x, chunk.y);
            }
            else {
                if (Input.lastInputSource === "gamepad") {
                    GAMEPAD_ICONS[chunk.controllerIcon].render(rt, chunk.x, chunk.y, 0.5);
                }
                else {
                    rt.fill(chunk.textColor);
                    rt.text(chunk.keyboardText, chunk.x, chunk.y);
                }
            }
        }
        rt.pop();
    }
}
/* ----- end of file ----- */

/* ----- src/entities/checkpoint.ts ----- */
/** A checkpoint. */
class Checkpoint extends KEntityBase {
    constructor(x, y) {
        super();
        this.displayLayer = -7;
        this.tags = [
            EntityTag.CHECKPOINT
        ];

        this._active = false;
        this.animationDirection = 0; // 1 = raising flag, -1 = lowering flag
        this.animationTime = 0;
        this.animating = false;
        // where the player should spawn when the checkpoint is active
        this.playerSpawn = [-1, -1];

        this.position = new Vector2D(x, y);
        this.collider = new RectCollider(x - 17, y - 50, 34, 50);
        this.playerSpawn = [x, y - 15];
    }

    // getter/setter to automatically start animations when the checkpoint is activated
    get active() { return this._active; }
    set active(value) {
        this._active = value;
        this.animating = true;
        if (this._active) {
            this.animationTime = 0;
            this.animationDirection = 1;
        }
        // only animate if the flag was actually raised
        else if (this.animationTime >= 0.5) {
            this.animationTime = 0.5;
            this.animationDirection = -1;
        }
    }

    // for animating the flag
    static easeFlagPos(x) {
        let t = x / 0.5;
        return (
            x <= 0 ? 0 :
            x >= 0.5 ? -50 :
            (1 - Math.pow(1 - t, 3)) * -50
        );
    }

    render(rt) {
        rt.push();
        rt.translate(this.position.x, this.position.y);

        // flagpole
        rt.noStroke();
        rt.fill("#3e3e60");
        rt.rect(-17, -50, 5, 50);

        // flag
        if (this.animating) {
            rt.fill("#386fe5");
            const flagHeight = Checkpoint.easeFlagPos(this.animationTime);
            // draw different polygons depending on where the flag is
            if (flagHeight > -10) {
                rt.beginShape();
                rt.vertex(-12, flagHeight);
                rt.vertex(12, flagHeight);
                rt.vertex(2 - flagHeight, 0);
                rt.vertex(-12, 0);
                rt.endShape("close");
            }
            else if (flagHeight > -20) {
                rt.beginShape();
                rt.vertex(-12, flagHeight);
                rt.vertex(12, flagHeight);
                rt.vertex(2, flagHeight + 10);
                rt.vertex(12 + flagHeight, 0);
                rt.vertex(-12, 0);
                rt.endShape("close");
            }
            else {
                rt.beginShape();
                rt.vertex(-12, flagHeight);
                rt.vertex(12, flagHeight);
                rt.vertex(2, flagHeight + 10);
                rt.vertex(12, flagHeight + 20);
                rt.vertex(-12, flagHeight + 20);
                rt.endShape("close");
            }
        }
        else if (this._active) {
            rt.fill("#386fe5");
            rt.beginShape();
            rt.vertex(-12, -50);
            rt.vertex(12, -50);
            rt.vertex(2, -40);
            rt.vertex(12, -30);
            rt.vertex(-12, -30);
            rt.endShape("close");
        }
        
        rt.pop();
    }
    update(dt) {
        // update animation
        if (this.animating) {
            this.animationTime += dt * this.animationDirection;
            if (this.animationTime <= 0 || this.animationTime >= 0.5) {
                this.animating = false;
            }
        }

        // only check collisions if we aren't the active checkpoint
        if (this._active) {
            return;
        }
        if (Globals.player.collider.isColliding(this.collider)) {
            this.active = true; // also starts the animation
            Globals.playerSpawn = this.playerSpawn;

            // deactivate all other checkpoints
            const checkpoints = Kepler.getTagged(EntityTag.CHECKPOINT);
            for (const c of checkpoints) {
                if (c !== this) {
                    c.active = false;
                }
            }
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/bullet-wall.ts ----- */
/** A stationary wall of bullets. */
class BulletWall extends KEntityBase {
    constructor(x1, y1, x2, y2) {
        super();
        this.displayLayer = -10;

        // shot timers are offset to make them appear more random
        this.bulletShotTimers = [];

        this.start = new Vector2D(x1, y1);
        this.end = new Vector2D(x2, y2);

        const delta = this.end.copy().sub(this.start);
        this.shotAngle = delta.heading() - Math.PI / 2;
        this.renderLength = delta.mag();

        // offset slightly forward so that the bullets don't appear on top of the mount
        const bulletOrigin = Vector2D.fromPolar(this.shotAngle + Math.PI / 2, 20).add(this.start);
        this.bulletSpawns = [
            bulletOrigin.copy(),
            Vector2D.fromPolar(this.shotAngle, 12).add(bulletOrigin),
            Vector2D.fromPolar(this.shotAngle, -12).add(bulletOrigin)
        ];

        // precalculate bullet velocity to save performance
        this.bulletVelocity = Vector2D.fromPolar(this.shotAngle + Math.PI / 2, 750);

        // add some random offsets to bullet timers
        for (let i = 0; i < this.bulletSpawns.length; ++i) {
            this.bulletShotTimers.push(Globals.random.float(CONSTANTS.BULLET_WALL_MIN_SHOT_DELAY, CONSTANTS.BULLET_WALL_MAX_SHOT_DELAY));
        }
    }
    render(rt) {
        rt.push();
        rt.translate(this.start.x, this.start.y);
        rt.rotate(this.shotAngle);
        rt.noStroke();

        // mounts
        rt.fill("#20272f");
        rt.quad(-15, 0, -12, 5, 12, 5, 15, 0);
        rt.quad(-15, this.renderLength, -12, this.renderLength - 5, 12, this.renderLength - 5, 15, this.renderLength);

        rt.pop();
    }

    update(dt) {
        // update timers and spawn bullets
        for (let i = 0; i < this.bulletShotTimers.length; ++i) {
            this.bulletShotTimers[i] -= dt;

            if (this.bulletShotTimers[i] < 0) {
                this.bulletShotTimers[i] = Globals.random.float(CONSTANTS.BULLET_WALL_MIN_SHOT_DELAY, CONSTANTS.BULLET_WALL_MAX_SHOT_DELAY);

                Kepler.addEntity(new Bullet(this.bulletSpawns[i].copy(), this.bulletVelocity.copy(), null));
            }
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/melee-enemy.ts ----- */
/** An enemy that charges at the player. */
class MeleeEnemy extends EnemyBase {
    constructor(x, y) {
        super();
        this.canSeePlayer = false;

        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(); // defaults to a zero vector
        this.collider = new RectCollider(x - 10, y - 15, 20, 30);
    }
    render(rt) {
        // body
        rt.noStroke();
        rt.fill("#f71f1f");
        rt.rect(this.collider.x, this.collider.y, this.collider.width, this.collider.height);

        // show detection radius
        if (Kepler.showHitboxes) {
            rt.noFill();
            rt.stroke(this.canSeePlayer ? "#00ff00" : "#ff00ff");
            rt.strokeWeight(4);
            rt.circle(this.position.x, this.position.y, CONSTANTS.MELEE_ENEMY_DETECTION_RADIUS * 2);
        }
    }

    update(dt) {
        // used for both collision and player detection
        const walls = Kepler.getTagged(EntityTag.WALL_COLLISION);

        // distance to the player, squared
        const playerDistance = Globals.player.position.copy().sub(this.position).magSq();
        this.canSeePlayer = (playerDistance < Math.pow(CONSTANTS.MELEE_ENEMY_DETECTION_RADIUS, 2));

        let moveDir = 0;
        // run at the player if we can see them, otherwise come to a stop
        if (this.canSeePlayer) {
            // run at the player
            if (Globals.player.position.x < this.position.x) {
                moveDir = -1;
            }
            else {
                moveDir = 1;
            }
        }
        else if (this.velocity.x !== 0) {
            if (this.velocity.x > 0) {
                moveDir = -1;
            }
            else {
                moveDir = 1;
            }
        }
        
        if (moveDir !== 0) {
            // prevents weird vibrations at low speed
            const snapSpeedZero = (
                Math.abs(this.velocity.x) < CONSTANTS.MELEE_ENEMY_ACCELERATION * dt &&
                (this.velocity.x < 0 && moveDir > 0) || (this.velocity.x > 0 && moveDir < 0)
            );
            if (snapSpeedZero) {
                this.velocity.x = 0;
            }
            else {
                this.velocity.x += CONSTANTS.MELEE_ENEMY_ACCELERATION * moveDir * dt;
                this.velocity.x = clamp(this.velocity.x, -CONSTANTS.MELEE_ENEMY_RUN_SPEED, CONSTANTS.MELEE_ENEMY_RUN_SPEED);
            }
        }

        // apply gravity and move
        this.velocity.y += CONSTANTS.GRAVITY * dt;
        this.position.add(this.velocity.copy().mult(dt));
        this.collider.centerX = this.position.x;
        this.collider.centerY = this.position.y;

        // collide with walls
        for (const wall of walls) {
            // trans rights!
            const transVec = new Vector2D();
            // isColliding() sets a translation vector using a reference
            if (this.collider.isColliding(wall.collider, transVec)) {
                this.position.add(transVec);
                this.collider.centerX = this.position.x;
                this.collider.centerY = this.position.y;

                // cancel velocity on the correct axis
                if (transVec.x !== 0) {
                    this.velocity.x = 0;
                }

                // a translation vector where both components are nonzero (or both components are zero) *should* be impossible
                else {
                    this.velocity.y = 0;
                }
            }
        }

        // collide with the player
        if (this.collider.isColliding(Globals.player.hurtbox) && !Globals.player.hasIFrames) {
            Globals.player.onDeath();
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/level-exit.ts ----- */
class LevelExit extends KEntityBase {
    constructor(x, y) {
        super();
        this.collider = new RectCollider(x - 25, y - 30, 40, 60);
    }
    
    render(rt) {
        rt.noStroke();
        rt.fill("#007ef3");
        rt.rect(this.collider.x, this.collider.y, this.collider.width, this.collider.height);

        rt.fill("#51c8ff");
        rt.rect(this.collider.x + 5, this.collider.y + 5, this.collider.width - 10, this.collider.height - 10);

        rt.fill("#2c2f36");
        rt.circle(this.collider.x + 27, this.collider.y + 30, 6);
    }

    update(dt) {
        if (this.collider.isColliding(Globals.player.collider)) {
            changeGameState(GameState.LEVEL_COMPLETE);
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/entities/spikes.ts ----- */
/** Deadly spikes */
class SpikeWall extends KEntityBase {
    constructor(x, y, facingDirection) {
        super();
        this.position = new Vector2D(x, y);
        
        // rotate collider and sprite to the correct angle
        switch (facingDirection) {
            case "up":
                this.collider = new RectCollider(x - 13, y + 3, 26, 12);
                this.spriteAngle = 0;
                break;
            case "down":
                this.collider = new RectCollider(x - 13, y - 15, 26, 12);
                this.spriteAngle = Math.PI;
                break;
            case "left":
                this.collider = new RectCollider(x + 3, y - 13, 12, 26);
                this.spriteAngle = -Math.PI / 2;
                break;
            case "right":
                this.collider = new RectCollider(x - 15, y - 13, 12, 26);
                this.spriteAngle = Math.PI / 2;
                break;
        }
    }

    render(rt) {
        rt.push();
        rt.translate(this.position.x, this.position.y);
        rt.rotate(this.spriteAngle);

        rt.noStroke();
        rt.fill("#8b939e");
        rt.triangle(-10, 0, -15, 15, -5, 15);
        rt.triangle(0, 0, -5, 15, 5, 15);
        rt.triangle(10, 0, 5, 15, 15, 15);

        rt.pop();
    }

    update(dt) {
        if (this.collider.isColliding(Globals.player.collider)) {
            Globals.player.onDeath();
        }
    }
}
/* ----- end of file ----- */ 

/* ----- src/ui/ui-page.ts ----- */
/** Manages a set of UI pages. */
const UIManager = (() => {
    // all UI elements, organized into pages
    let pages = {};
    let currentPage = null;
    let lastCursorPos = "none";

    // the canvas to draw elements on
    let _renderTarget;

    // the element that the mouse is over or the gamepad cursor is on
    let hoveredElement = null;

    return {
        get renderTarget() { return _renderTarget; },
        set renderTarget(value) { _renderTarget = value; },

        init(p5, rt) {
            _renderTarget = rt ?? p5;
        },

        getCurrentPage() {
            return currentPage.name;
        },

        setCurrentPage(pageName) {
            // always unload the hovered element
            if (hoveredElement !== null) {
                hoveredElement.hovered = false;
                hoveredElement = null;
            }

            if (pageName === "none") {
                currentPage = null;
                return;
            }

            if (!Object.keys(pages).includes(pageName)) {
                throw new InvalidArgumentError(`[UIManager] The ui page "${pageName}" does not exist!`);
            }
            else {
                currentPage = pages[pageName];
                lastCursorPos = Object.keys(currentPage.elements)[0];
            }
        },

        update() {
            if (currentPage === null) {
                return;
            }
            // update hovered element
            if (Input.lastInputSource === "keyboard") {
                if (hoveredElement !== null && !hoveredElement.checkHover(_renderTarget.mouseX, _renderTarget.mouseY)) {
                    hoveredElement.hovered = false;
                    hoveredElement = null;
                }
                else {
                    for (const [name, element] of Object.entries(currentPage.elements)) {
                        if (element.checkHover(_renderTarget.mouseX, _renderTarget.mouseY)) {
                            hoveredElement = element;
                            hoveredElement.hovered = true;
                            lastCursorPos = name;
                        }
                    }
                }
            }
            else {
                if (hoveredElement !== null) {
                    hoveredElement.hovered = false;
                }

                const inputDir = (
                    Input.isActive("menu up") ? "up" :
                    Input.isActive("menu down") ? "down" :
                    Input.isActive("menu left") ? "left" :
                    Input.isActive("menu right") ? "right" :
                    "none"
                );
                if (inputDir !== "none" && currentPage.cursorMap[lastCursorPos]) {
                    if (currentPage.cursorMap[lastCursorPos][inputDir]) {
                        lastCursorPos = currentPage.cursorMap[lastCursorPos][inputDir];
                    }
                }

                if (lastCursorPos !== "none") {
                    hoveredElement = currentPage.elements[lastCursorPos];
                    hoveredElement.hovered = true;
                }
            }

            // activate menu element if possible
            if (Input.isActive("menu confirm") && hoveredElement !== null) {
                hoveredElement.onClick();
            }
        },

        render() {
            if (currentPage === null) {
                return;
            }
            for (const element of Object.values(currentPage.elements)) {
                _renderTarget.push();
                element.render(_renderTarget);
                _renderTarget.pop();
            }
        },

        addPage(page) {
            if (page.name === "none") {
                throw new InvalidArgumentError("[UIManager] \"none\" is a reserved page name!");
            }
            if (Object.keys(pages).includes(page.name)) {
                throw new InvalidArgumentError(`[UIManager] The page "${page.name}" already exists!`);
            }

            pages[page.name] = {
                name: page.name,
                elements: page.elements,
                cursorMap: page.cursorMap ?? {}
            };
        },
    };
})();

/** Base class for UI elements. */
class UIElementBase {
    constructor() {
        this.hovered = false;
    }

    // returns whether the mouse is over the element
    checkHover(mouseX, mouseY) {
        return false;
    }
}
/* ----- end of file ----- */ 

/* ----- src/ui/text-button.ts ----- */
/** A UI button with some text on it. */
class TextButton extends UIElementBase {
    constructor({ x, y, width, height, text, textSize, textFont, callback }) {
        super();
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.text = text;
        this.textSize = textSize;
        this.textFont = textFont;
        this.callback = callback;
    }

    checkHover(mouseX, mouseY) {
        return (
            mouseX >= this.x && mouseX <= this.x + this.width &&
            mouseY >= this.y && mouseY <= this.y + this.height
        );
    }

    render(rt) {
        rt.noStroke();
        rt.fill("#000000");
        rt.textAlign("center", "center");
        rt.textFont(this.textFont, this.textSize);
        rt.text(this.text, this.x + this.width / 2, this.y + this.height / 2);

        if (this.hovered) {
            rt.noFill();
            rt.stroke("#000000");
            rt.strokeWeight(4);

            rt.beginShape();
            rt.vertex(this.x, this.y + 15);
            rt.vertex(this.x, this.y);
            rt.vertex(this.x + 15, this.y);
            rt.endShape();

            rt.beginShape();
            rt.vertex(this.x + this.width, this.y + 15);
            rt.vertex(this.x + this.width, this.y);
            rt.vertex(this.x + this.width - 15, this.y);
            rt.endShape();

            rt.beginShape();
            rt.vertex(this.x, this.y + this.height - 15);
            rt.vertex(this.x, this.y + this.height);
            rt.vertex(this.x + 15, this.y + this.height);
            rt.endShape();

            rt.beginShape();
            rt.vertex(this.x + this.width, this.y + this.height - 15);
            rt.vertex(this.x + this.width, this.y + this.height);
            rt.vertex(this.x + this.width - 15, this.y + this.height);
            rt.endShape();
        }
    }

    onClick() {
        this.callback();
    }
}
/* ----- end of file ----- */

/* ----- src/npc-logo.ts ----- */
/** Draws my personal logo. Returns `true` if the animation is finished. */
const drawNpcLogo = (() => {
    const LOGO_COLORS = {
        // technically these aren't the "true" colors, but they're close enough and they look better
        BI_PINK: "#d60270",
        BI_PURPLE: "#9b4f96",
        BI_BLUE: "#1250cc",
        BACKGROUND: "#352a55",
        TEXT: "#ffffff"
    };

    // internal constants
    let t = 0;
    const line1Times = [0, 0, 0];
    const line2Times = [0, 0, 0, 0, 0, 0];
    const line3Times = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    let animationState = 0;

    function drawN(x, y, time, p5) {
        const leftLength = p5.lerp(24, -20, p5.constrain(time, 0, 16) / 16);
        const arc1Angle = p5.lerp(0, 168, p5.constrain(time - 16, 0, 6) / 6);
        const middleX = p5.lerp(-5, 5, p5.constrain(time - 22, 0, 16) / 16);
        const middleY = p5.lerp(-21, 21, p5.constrain(time - 22, 0, 16) / 16);
        const arc2Angle = p5.lerp(168, 0, p5.constrain(time - 38, 0, 6) / 6);
        const rightLength = p5.lerp(20, -24, p5.constrain(time - 44, 0, 16) / 16);
        if (time > 0) {
            p5.line(x - 15, y + leftLength, x - 15, y + 24);
        }
        if (time > 16) {
            p5.arc(x - 10, y - 20, 10, 10, -180, -180 + arc1Angle);
        }
        if (time > 22) {
            p5.line(x - 5, y - 21, x + middleX, y + middleY);
        }
        if (time > 38) {
            p5.arc(x + 10, y + 20, 10, 10, arc2Angle, 168);
        }
        if (time > 44) {
            p5.line(x + 15, y + rightLength, x + 15, y + 20);
        }
    }
    function drawP(x, y, time, p5) {
        const leftLength = p5.lerp(25, -25, p5.constrain(time, 0, 26) / 26);
        const topWidth = p5.lerp(-15, -5, p5.constrain(time - 26, 0, 6) / 6);
        const arc2Angle = p5.lerp(-90, 90, p5.constrain(time - 32, 0, 24) / 24);
        const bottomWidth = p5.lerp(-5, -15, p5.constrain(time - 56, 0, 4) / 4);
        if (time > 0) {
            p5.line(x - 15, y + 25, x - 15, y + leftLength);
        }
        if (time > 28) {
            p5.line(x - 15, y - 25, x + topWidth, y - 25);
        }
        if (time > 32) {
            p5.arc(x - 5, y - 11.5, 27, 27, -90, arc2Angle);
        }
        if (time > 56) {
            p5.line(x + bottomWidth, y + 2, x - 5, y + 2);
        }
    }
    function drawC(x, y, time, p5) {
        const arcAngle = p5.lerp(45, 315, p5.constrain(time, 0, 60) / 60);
        if (time > 0) {
            p5.arc(x + 6, y, 42, 50, 45, arcAngle);
        }
    }
    function drawO(x, y, time, p5) {
        const arcAngle = p5.lerp(90, 450, p5.constrain(time, 0, 60) / 60);
        if (time > 0) {
            p5.arc(x + 6, y, 42, 50, 90, arcAngle);
        }
    }
    function drawL(x, y, time, p5) {
        const leftLength = p5.lerp(-25, 15, p5.constrain(time, 0, 36) / 36);
        const arcAngle = p5.lerp(180, 90, p5.constrain(time - 36, 0, 12) / 12);
        const bottomWidth = p5.lerp(-7, 5, p5.constrain(time - 48, 0, 12) / 12);
        if (time > 0) {
            p5.line(x - 15, y + leftLength, x - 15, y - 25);
        }
        if (time > 36) {
            p5.arc(x - 7, y + 17, 16, 16, arcAngle, 180);
        }
        if (time > 48) {
            p5.line(x - 7, y + 25, x + bottomWidth, y + 25);
        }
    }
    function drawA(x, y, time, p5) {
        const leftX = p5.lerp(-18, -6, p5.constrain(time, 0, 24) / 24);
        const leftY = p5.lerp(25, -22, p5.constrain(time, 0, 24) / 24);
        const arcAngle = p5.lerp(200, 350, p5.constrain(time - 24, 0, 12) / 12);
        const rightX = p5.lerp(6, 18, p5.constrain(time - 36, 0, 24) / 24);
        const rightY = p5.lerp(-22, 25, p5.constrain(time - 36, 0, 24) / 24);
        const barLength = p5.lerp(-10, 10, p5.constrain(time - 12, 0, 36) / 36);
        if (time > 0) {
            p5.line(x - 18, y + 25, x + leftX, y + leftY);
        }
        if (time > 24) {
            p5.arc(x, y - 20, 12, 12, 200, arcAngle);
        }
        if (time > 36) {
            p5.line(x + 6, y - 22, x + rightX, y + rightY);
        }
        if (time > 12) {
            p5.line(x - 10, y + 3, x + barLength, y + 3);
        }
    }
    function drawY(x, y, time, p5) {
        const leftX = p5.lerp(-15, -6, p5.constrain(time, 0, 24) / 24);
        const leftY = p5.lerp(-25, -3, p5.constrain(time, 0, 24) / 24);
        const arcAngle = p5.lerp(155, 25, p5.constrain(time - 24, 0, 12) / 12);
        const rightX = p5.lerp(6, 15, p5.constrain(time - 36, 0, 24) / 24);
        const rightY = p5.lerp(-3, -25, p5.constrain(time - 36, 0, 24) / 24);
        const barLength = p5.lerp(1, 25, p5.constrain(time - 30, 0, 30) / 30);
        if (time > 0) {
            p5.line(x - 15, y - 25, x + leftX, y + leftY);
        }
        if (time > 24) {
            p5.arc(x, y - 5, 12, 12, arcAngle, 155);
        }
        if (time > 36) {
            p5.line(x + rightX, y + rightY, x + 6, y - 3);
        }
        if (time > 30) {
            p5.line(x, y + 1, x, y + barLength);
        }
    }
    function drawE(x, y, time, p5) {
        const topLength = p5.lerp(10, -5, p5.constrain(time, 0, 10) / 10);
        const arc1Angle = p5.lerp(270, 180, p5.constrain(time - 10, 0, 10) / 10);
        const leftLength = p5.lerp(-15, 15, p5.constrain(time - 20, 0, 20) / 20);
        const arc2Angle = p5.lerp(180, 90, p5.constrain(time - 40, 0, 10) / 10);
        const bottomLength = p5.lerp(-5, 10, p5.constrain(time - 50, 0, 10) / 10);
        const middleLength = p5.lerp(-15, 10, p5.constrain(time - 30, 0, 30) / 30);
        if (time > 0) {
            p5.line(x + topLength, y - 25, x + 10, y - 25);
        }
        if (time > 10) {
            p5.arc(x - 5, y - 15, 20, 20, arc1Angle, 270);
        }
        if (time > 20) {
            p5.line(x - 15, y - 15, x - 15, y + leftLength);
        }
        if (time > 40) {
            p5.arc(x - 5, y + 15, 20, 20, arc2Angle, 180);
        }
        if (time > 50) {
            p5.line(x - 5, y + 25, x + bottomLength, y + 25);
        }
        if (time > 30) {
            p5.line(x - 15, y, x + middleLength, y);
        }
    }
    function drawR(x, y, time, p5) {
        const leftLength = p5.lerp(25, -25, p5.constrain(time, 0, 26) / 26);
        const topWidth = p5.lerp(-15, -5, p5.constrain(time - 26, 0, 6) / 6);
        const arc2Angle = p5.lerp(-90, 90, p5.constrain(time - 32, 0, 24) / 24);
        const bottomWidth = p5.lerp(-5, -15, p5.constrain(time - 56, 0, 4) / 4);
        const legX = p5.lerp(5, -5, p5.constrain(time - 26, 0, 30) / 30);
        const legY = p5.lerp(25, 0, p5.constrain(time - 26, 0, 30) / 30);
        if (time > 0) {
            p5.line(x - 15, y + 25, x - 15, y + leftLength);
        }
        if (time > 28) {
            p5.line(x - 15, y - 25, x + topWidth, y - 25);
        }
        if (time > 32) {
            p5.arc(x - 5, y - 12.5, 25, 25, -90, arc2Angle);
        }
        if (time > 56) {
            p5.line(x + bottomWidth, y, x - 5, y);
        }
        if (time > 26) {
            p5.line(x + legX, y + legY, x + 5, y + 25);
        }
    }
    function drawH(x, y, time, p5) {
        const legLength = p5.lerp(-25, 25, p5.constrain(time, 0, 60) / 60);
        const barLength = p5.lerp(-14, 14, p5.constrain(time - 30, 0, 30) / 30);
        if (time > 0) {
            p5.line(x - 15, y - 25, x - 15, y + legLength);
            p5.line(x + 15, y - legLength, x + 15, y + 25);
        }
        if (time > 30) {
            p5.line(x - 14, y, x + barLength, y);
        }
    }
    function drawT(x, y, time, p5) {
        const barLength = p5.lerp(-15, 15, p5.constrain(time - 30, 0, 30) / 30);
        const legLength = p5.lerp(-25, 25, p5.constrain(time, 0, 60) / 60);
        if (time > 30) {
            p5.line(x - 15, y - 25, x + barLength, y - 25);
        }
        if (time > 0) {
            p5.line(x, y + -25, x, y + legLength);
        }
    }

    function easeIn(x) {
        const t = (x - 0) / 1;
        return (x <= 0 ? 0 :
            x >= 1 ? 60 :
                x <= 0.5 ? 2 * Math.pow(t, 2) * 60 + 0 :
                    60 - Math.pow(-2 * t + 2, 2) / 2 * 60);
    }

    function easeOut(x) {
        const t = (x - 3) / 0.5;
        return (x <= 3 ? 60 :
            x >= 3.5 ? 0 :
                x <= 3.25 ? 2 * Math.pow(t, 2) * -60 + 60 :
                    0 - Math.pow(-2 * t + 2, 2) / 2 * -60);
    }

    function getTime(t) {
        t = (t < 0 ? 0 : t > 210 ? 210 : t);
        if (t < 1) {
            return easeIn(t);
        }
        else if (t < 3) {
            return 60;
        }
        else if (t < 3.5) {
            return easeOut(t);
        }
        else {
            return 0;
        }
    }

    return (p5) => {
        // native delta time is in milliseconds
        t += (p5.deltaTime / 1000) * 1.25;
        if (t > 4) {
            return true;
        }
        else if (t > 3) {
            animationState = 1;
        }

        if (animationState === 0) {
            for (let i = 0; i < line1Times.length; ++i) {
                line1Times[i] = getTime(t - i * 0.1);
            }
            for (let i = 0; i < line2Times.length; ++i) {
                line2Times[i] = getTime(t - 0.25 - i * 0.1);
            }
            for (let i = 0; i < line3Times.length; ++i) {
                line3Times[i] = getTime(t - 0.5 - i * 0.1);
            }
        }

        else {
            for (let i = 0; i < line1Times.length; ++i) {
                line1Times[i] = getTime(t);
            }
            for (let i = 0; i < line2Times.length; ++i) {
                line2Times[i] = getTime(t);
            }
            for (let i = 0; i < line3Times.length; ++i) {
                line3Times[i] = getTime(t);
            }
        }

        p5.angleMode("degrees");
        p5.background(LOGO_COLORS.BACKGROUND);
        p5.strokeWeight(6);
        p5.noFill();
        p5.stroke(LOGO_COLORS.BI_PINK);
        drawN(125, 225, line1Times[0], p5);
        p5.stroke(LOGO_COLORS.BI_PURPLE);
        drawP(125, 300, line2Times[0], p5);
        p5.stroke(LOGO_COLORS.BI_BLUE);
        drawC(125, 375, line3Times[0], p5);
        p5.strokeWeight(4);
        p5.stroke(LOGO_COLORS.TEXT);
        drawO(173, 225, line1Times[1], p5);
        drawN(232, 225, line1Times[2], p5);
        drawL(170, 300, line2Times[1], p5);
        drawA(210, 301, line2Times[2], p5);
        drawY(255, 300, line2Times[3], p5);
        drawE(300, 300, line2Times[4], p5);
        drawR(345, 300, line2Times[5], p5);
        drawH(180, 375, line3Times[1], p5);
        drawA(233, 375, line3Times[2], p5);
        drawR(285, 375, line3Times[3], p5);
        drawA(328, 375, line3Times[4], p5);
        drawC(375, 375, line3Times[5], p5);
        drawT(425, 375, line3Times[6], p5);
        drawE(470, 375, line3Times[7], p5);
        drawR(515, 375, line3Times[8], p5);
        p5.angleMode("radians");
        return false;
    };
})();
/* ----- end of file ----- */ 

/* ----- src/game-states.ts ----- */
// lookup table for entity constructors
const ENTITY_CTORS = {
    [LevelEntity.WALL]: Wall,
    [LevelEntity.WALLRUN_SURFACE]: WallrunSurface,
    [LevelEntity.TURRET_ENEMY]: TurretEnemy,
    [LevelEntity.STATIC_LASER]: StaticLaser,
    [LevelEntity.FLOATING_TEXT]: FloatingText,
    [LevelEntity.CHECKPOINT]: Checkpoint,
    [LevelEntity.BULLET_WALL]: BulletWall,
    [LevelEntity.MELEE_ENEMY]: MeleeEnemy,
    [LevelEntity.LEVEL_EXIT]: LevelExit,
    [LevelEntity.SPIKES]: SpikeWall
};

/**
 * Loads a new level.
 */
function loadLevel(levelIndex) {
    console.log("Loading level...");

    Globals.currentLevelIndex = levelIndex;
    const levelData = LEVELS[levelIndex];

    // purge remaining entities (if any)
    Kepler.deleteAll();
    // reset camera
    Kepler.setViewportBounds(levelData.viewportBounds);

    // addEntity() returns a reference for faster access
    Globals.player = Kepler.addEntity(new Player(...levelData.playerSpawn));

    // add all entities
    for (const entityData of levelData.entities) {
        Kepler.addEntity(new ENTITY_CTORS[entityData[0]](...entityData.slice(1)));
    }

    Globals.playerSpawn = levelData.playerSpawn;
}
/**
 * Transitions to a new game state and runs any state-specific code. Use this to change the current game state - do not set `Globals.gameState` directly!
 */
changeGameState = (newState) => {
    switch (newState) {
        case GameState.GAMEPLAY:
            UIManager.setCurrentPage("none");
            break;
        case GameState.MAIN_MENU:
            UIManager.setCurrentPage("main menu");
            break;
        case GameState.LEVEL_SELECT:
            UIManager.setCurrentPage("level select");
            break;
        case GameState.LEVEL_COMPLETE:
            if (Globals.currentLevelIndex === LEVELS.length - 1) {
                // alternate ui page that doesn't have a "next level" button
                UIManager.setCurrentPage("final level complete");
            }
            else {
                UIManager.setCurrentPage("level complete");
            }
            break;
    }
    Globals.gameState = newState;
};

// update and render functions for every game state
const GAME_STATE_HANDLERS = {
    [GameState.NPC_LOGO]: {
        update() { },
        render() {
            // drawNpcLogo() returns true when the animation is finished
            if (drawNpcLogo(Globals.p5)) {
                changeGameState(GameState.MAIN_MENU);
            }
        },
    },
    [GameState.MAIN_MENU]: {
        update() {
            UIManager.update();
        },
        render(rt) {
            rt.background("#ffffff");

            rt.push();
            rt.fill("#000000");
            rt.textFont("Tomorrow", 100);
            rt.textAlign("center", "center");
            rt.textStyle("italic");
            rt.text("BladeRun", 300, 100);
            rt.pop();

            UIManager.render();
        },
    },
    [GameState.LEVEL_SELECT]: {
        update() {
            UIManager.update();

            if (Input.isActive("menu back")) {
                changeGameState(GameState.MAIN_MENU);
            }
        },
        render(rt) {
            rt.background("#ffffff");

            rt.push();
            rt.fill("#000000");
            rt.textFont("Tomorrow", 60);
            rt.textAlign("center", "center");
            rt.text("Level Select", 300, 65);
            rt.pop();

            rt.textFont("Tomorrow", 50);
            rt.textAlign("center", "center");

            UIManager.render();
        },
    },
    [GameState.GAMEPLAY]: {
        // update() is only called when the dev console is not open
        update() {
            Kepler.update();
        },
        // render() is called at all times
        render() {
            Kepler.render();
        },
    },
    [GameState.LEVEL_COMPLETE]: {
        update() {
            UIManager.update();
        },
        render(rt) {
            rt.background("#ffffff");

            rt.push();
            rt.fill("#000000");
            rt.textFont("Tomorrow", 70);
            rt.textAlign("center", "center");
            rt.text("Level Complete", 300, 100);
            rt.pop();

            UIManager.render();
        },
    },
};
/* ----- end of file ----- */ 

/* ----- src/console-commands.ts ----- */ 
/** All console commands. */
const CONSOLE_COMMANDS = [
    {
        name: "sv_showHitboxes",
        description: "Enables or disables rendering entity hitboxes.",
        signatures: [
            [],
            ["bool"]
        ],
        callback(value) {
            Kepler.showHitboxes = value;
            console.log(`sv_showHitboxes = ${value}`);
        }
    },
    {
        name: "load_level",
        description: ("Loads a new level. This command uses the level ID, not the level's display name."),
        signatures: [
            ["int"]
        ],
        callback(levelId) {
            if (LEVELS[levelId]) {
                loadLevel(levelId);
                changeGameState(GameState.GAMEPLAY);
            }
            else {
                console.error(`The level ID "${levelId}" does not exist!`);
            }
        }
    },
    {
        name: "kill_player",
        description: "Self-explanatory",
        signatures: [[]],
        callback() {
            Globals.player.onDeath();
        }
    }
];
/* ----- end of file ----- */ 

/* ----- src/main.ts ----- */
// creates the actual sketch instance
const sketch = (p5) => {
    let lastFrameRate = 0;
    let frameRateUpdateTimer = 1;
    let elapsedFrames = 0;

    Globals.random = new SplitMix32();

    p5.setup = () => {
        Globals.p5 = p5;
        // environment setup
        const canvas = p5.createCanvas(600, 600);

        // get a second reference to the canvas i just created, which i need because p5js is a PERFECT library with NO FLAWS WHATSOEVER
        const c = document.getElementById(canvas.id());
        // helps make mouse and keyboard functions only trigger when they should
        c.tabIndex = -1;
        // disable the right-click menu
        c.addEventListener("contextmenu", (e) => e.preventDefault());

        // initialize everything
        Input.init(canvas, new GamepadManager());
        Kepler.init(p5);
        Kepler.cameraEnabled = true;
        DevConsole.init(p5, canvas);

        // add commands to dev console
        for (const command of CONSOLE_COMMANDS) {
            DevConsole.registerFunction(command);
        }

        // setup inputs
        for (const [name, action] of Object.entries(KEYBINDS)) {
            if (name === "up" || name === "down" || name === "left" || name === "right") {
                // the menu needs press actions for directions
                Input.addAction({
                    name: `menu ${name}`,
                    keys: action.keys,
                    buttons: action.buttons,
                    type: "press"
                });
            }
            if (name === "wallrun") {
                // having a press action to initiate a wallrun simplifies some player movement code
                Input.addAction({
                    name: "start wallrun",
                    keys: action.keys,
                    buttons: action.buttons,
                    type: "press"
                });
            }
            Input.addAction({
                name: name,
                keys: action.keys,
                buttons: action.buttons,
                type: CONSTANTS.PRESS_ACTIONS.includes(name) ? "press" : "hold"
            });
        }

        // setup ui
        UIManager.init(p5);
        // main menu
        UIManager.addPage({
            name: "main menu",
            elements: {
                "start game": new TextButton({
                    x: 190,
                    y: 272,
                    width: 220,
                    height: 56,
                    text: "Start Game",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        loadLevel(1); // level 0 is the debug level
                        changeGameState(GameState.GAMEPLAY);
                    },
                }),
                "level select": new TextButton({
                    x: 185,
                    y: 362,
                    width: 230,
                    height: 56,
                    text: "Level Select",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        changeGameState(GameState.LEVEL_SELECT);
                    },
                }),
            },
            cursorMap: {
                "start game": {
                    up: "level select",
                    down: "level select"
                },
                "level select": {
                    up: "start game",
                    down: "start game"
                }
            }
        });
        // level complete screen
        UIManager.addPage({
            name: "level complete",
            elements: {
                "next level": new TextButton({
                    x: 200,
                    y: 227,
                    width: 200,
                    height: 56,
                    text: "Next Level",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        loadLevel(Globals.currentLevelIndex + 1);
                        changeGameState(GameState.GAMEPLAY);
                    },
                }),
                "restart": new TextButton({
                    x: 242,
                    y: 317,
                    width: 116,
                    height: 56,
                    text: "Retry",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        // load the current level again to reset it
                        loadLevel(Globals.currentLevelIndex);
                        changeGameState(GameState.GAMEPLAY);
                    },
                }),
                "main menu": new TextButton({
                    x: 140,
                    y: 407,
                    width: 320,
                    height: 56,
                    text: "Exit to Main Menu",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        changeGameState(GameState.MAIN_MENU);
                    },
                }),
            },
            cursorMap: {
                "next level": {
                    up: "main menu",
                    down: "restart"
                },
                "restart": {
                    up: "next level",
                    down: "main menu"
                },
                "main menu": {
                    up: "restart",
                    down: "next level"
                },
            }
        });
        // alternate level complete screen without a next level button
        UIManager.addPage({
            name: "final level complete",
            elements: {
                "restart": new TextButton({
                    x: 242,
                    y: 272,
                    width: 116,
                    height: 56,
                    text: "Retry",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        // load the current level again to reset it
                        loadLevel(Globals.currentLevelIndex);
                        changeGameState(GameState.GAMEPLAY);
                    },
                }),
                "main menu": new TextButton({
                    x: 140,
                    y: 362,
                    width: 320,
                    height: 56,
                    text: "Exit to Main Menu",
                    textSize: 36,
                    textFont: "Tomorrow",
                    callback() {
                        changeGameState(GameState.MAIN_MENU);
                    },
                }),
            },
            cursorMap: {
                "restart": {
                    up: "main menu",
                    down: "main menu"
                },
                "main menu": {
                    up: "restart",
                    down: "restart"
                },
            }
        });

        // generate level select buttons
        const levelSelectButtons = {};
        const levelSelectCursorMap = {};

        // for the cursor map
        const bottomRow = Math.floor((LEVELS.length - 1) / 5);
        
        let levelIndex = 1;
        for (let y = 0; y < 4; ++y) {
            for (let x = 0; x < 5; ++x) {
                // use coordinates as the button name to make the cursor map easier
                const currentLevelIndex = levelIndex; // prevents some very strange bugs
                levelSelectButtons[`${x},${y}`] = new TextButton({
                    x: (x + 0.5) * 100 + 10,
                    y: (y + 1.25) * 100 + 10,
                    width: 80,
                    height: 80,
                    text: `${levelIndex}`,
                    textSize: 50,
                    textFont: "Tomorrow",
                    callback() {
                        loadLevel(currentLevelIndex);
                        changeGameState(GameState.GAMEPLAY);
                    }
                });
                
                // update cursor map
                const cursorMapNode = {};
                if (x > 0) {
                    cursorMapNode.left = `${x - 1},${y}`;
                }
                if (x < 4 && levelIndex < LEVELS.length - 1) {
                    cursorMapNode.right = `${x + 1},${y}`;
                }
                if (y > 0) {
                    cursorMapNode.up = `${x},${y - 1}`;
                }

                // all buttons on the bottom row are linked to the exit button
                if (y === bottomRow) {
                    cursorMapNode.down = "exit";
                }
                else {
                    cursorMapNode.down = `${x},${y + 1}`;
                }
                levelSelectCursorMap[`${x},${y}`] = cursorMapNode;

                // stop once we run out of levels
                ++levelIndex;
                if (levelIndex >= LEVELS.length) {
                    break;
                }
            }

            // stop once we run out of levels
            if (levelIndex >= LEVELS.length) {
                break;
            }
        }

        // add exit button
        levelSelectButtons["exit"] = new TextButton({
            x: 260,
            y: 535,
            width: 80,
            height: 56,
            text: "Exit",
            textSize: 36,
            textFont: "Tomorrow",
            callback() {
                changeGameState(GameState.MAIN_MENU);
            },
        });
        levelSelectCursorMap["exit"] = {
            up: `0,${bottomRow}`
        };

        UIManager.addPage({
            name: "level select",
            elements: levelSelectButtons,
            cursorMap: levelSelectCursorMap
        });

        changeGameState(SKIP_LOGO ? GameState.MAIN_MENU : GameState.NPC_LOGO);
    };
    p5.draw = () => {
        p5.background("#ffffff");

        // the game is paused whenever the console is open
        if (!DevConsole.open) {
            GAME_STATE_HANDLERS[Globals.gameState].update();
        }

        GAME_STATE_HANDLERS[Globals.gameState].render(p5);

        DevConsole.update();

        // frame rate counter
        ++elapsedFrames;
        frameRateUpdateTimer -= p5.deltaTime / 1000;
        if (frameRateUpdateTimer <= 0) {
            lastFrameRate = elapsedFrames;
            frameRateUpdateTimer = 1;
            elapsedFrames = 0;
        }

        p5.noStroke();
        p5.fill("#000000a0");
        p5.rect(540, 0, 60, 20);
        p5.textAlign("right", "top");
        p5.fill("#00ff00");
        p5.textFont("Roboto Mono", 14);
        p5.text(`${lastFrameRate} FPS`, 595, 4);
    };
};

// error checks need to be disabled here because otherwise typescript explodes for some reason
const instance = new p5(sketch);
/* ----- end of file ----- */ 
})();</script>

<!-- everything below this line was written by bluebird -->
</head>
<body style="margin:0;overflow:hidden;">
<!--The Thumbnail Script 2.1.0 12/18/2023 by Bluebird@kaid_157624541333313939750668--><script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script><script type>var r=600,s=document.documentElement.clientWidth;window.parent.html2canvas=t=>{try{html2canvas(document.body,{width:s,height:s,useCORS:!0,onclone:t=>t.getAnimations().forEach((t=>{try{t.finish()}catch{}}))}).then((t=>{var e=document.createElement("canvas");e.width=r,e.height=r,e.getContext("2d").drawImage(t,0,0,t.width,t.height,0,0,r,r),window.top.postMessage(e.toDataURL(),"*")})).catch((t=>{alert("Thumbnail Script Error: "+t)}))}catch{window.top.postMessage(document.createElement("canvas").toDataURL(),"*")}};
</script>
<script>/*Extra Script tag for reload button.*/</script>
</body>
</html>